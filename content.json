{"meta":{"title":"Smilecoc's Blog","subtitle":null,"description":"Welcome to My Blog","author":"Smilecoc","url":"http://smilecoc.vip","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-20T14:09:48.466Z","comments":false,"path":"about/index.html","permalink":"http://smilecoc.vip/about/index.html","excerpt":"","text":"[さくら荘のSmilecoc] 与&nbsp; Smilecoc&nbsp; （ こんにちは ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Smilecoc\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个爱折腾的的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"毕业于沈阳工业大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"学的物流却误入IT行业…\" }).then(function () { botui.message.add({ delay: 1200, content: \"从此踏上撸代码的不归路\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻Python和SQL，疯狂写过VBA，偶尔也折腾 HTML/CSS/JavaScript/R\" }).then(function () { botui.message.add({ delay: 1500, content: \"希望研究的方向，是数据分析（data science），数据仓库（data warehouse）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢游戏，动漫，摄影，永远在折腾自己喜欢的事情\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Smilecoc呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"其实是瞎取得~，希望可以永远smile吧coc\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么要建立这个网站呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"算是在对的时间遇上了对的人吧… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且可以留下一些很酷的东西，不是吗\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，带有花名而且便宜=.= \" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-05T18:28:07.113Z","comments":false,"path":"bangumi/index.html","permalink":"http://smilecoc.vip/bangumi/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-05T07:03:44.491Z","comments":true,"path":"links/index.html","permalink":"http://smilecoc.vip/links/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"client/index.html","permalink":"http://smilecoc.vip/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"http://smilecoc.vip/donate/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"http://smilecoc.vip/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"http://smilecoc.vip/rss/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"http://smilecoc.vip/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-01-29T08:36:05.608Z","comments":false,"path":"music/index.html","permalink":"http://smilecoc.vip/music/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://smilecoc.vip/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-05T18:06:58.412Z","comments":true,"path":"tags/index.html","permalink":"http://smilecoc.vip/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"video/index.html","permalink":"http://smilecoc.vip/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"books","date":"2020-07-05T18:05:48.000Z","updated":"2020-07-08T16:34:27.854Z","comments":false,"path":"tags/悦读/index.html","permalink":"http://smilecoc.vip/tags/悦读/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-05T18:06:49.673Z","comments":true,"path":"tags/图集/index.html","permalink":"http://smilecoc.vip/tags/图集/index.html","excerpt":"","text":"开发中，尽情期待！"}],"posts":[{"title":"sweetviz包：快速可视化和数据集EDA","slug":"sweetviz","date":"2020-07-27T02:08:45.000Z","updated":"2020-07-27T14:33:10.203Z","comments":true,"path":"2020/07/27/sweetviz/","link":"","permalink":"http://smilecoc.vip/2020/07/27/sweetviz/","excerpt":"","text":"Sweetviz是一个开放源代码Python库，可生成精美的高密度可视化文件，以单行代码启动EDA（探索性数据分析）。输出是一个完全独立的HTML应用程序。 该系统围绕快速可视化目标值和比较数据集而构建。其目标是帮助快速分析目标特征，训练与测试数据以及其他此类数据表征任务 安装pip install sweetviz 分析一个数据集注意：Sweetviz仅支持分析dataframe数据结构的数据 当分析一个dataframe时，先使用analyze() 函数, 然后使用 show_html() 函数产出一个1080p宽屏的网页 import sweetviz as sv import pandas as pd my_dataframe=pd.read_csv(&quot;train.csv&quot;) my_report = sv.analyze(my_dataframe) my_report.show_html() # 默认生成的html文件为&quot;SWEETVIZ_REPORT.html&quot; 可选参数analyze()函数的语法与可选参数为: analyze(source: Union[pd.DataFrame, Tuple[pd.DataFrame, str]], target_feat: str = None, feat_cfg: FeatureConfig = None, pairwise_analysis: str = &#39;auto&#39;):source：以pandas中的DataFrame数据结构、或是[DataFrame，str]的元组形式，其中str是DataFrame要在报表中显示的名称。target_feat：需要被标记为目标对象的字符串，目前仅支持 BOOLEAN和 NUMERICAL类型。feat_cfg：需要被跳过、或是需要被强制转换为某种数据类型的特征。参数可以为skip，force_cat，force_num和force_text，用法为： feature_config = sv.FeatureConfig(skip=&quot;PassengerId&quot;, force_text=[&quot;Age&quot;])pairwise_analysis：相关性和其他类型的数据关联可能需要花费较长时间。如果超过了某个阈值，就需要设置这个参数为on或者off，以判断是否需要分析数据相关性。 两个数据集的比较要比较两个数据集，只需使用compare()函数。除了第二个参数不同外，其参数与analyze()相同。建议使用参数的[dataframe，“ name”]格式，以更好地区分测试集与比较集。 my_report = sv.compare([my_dataframe, &quot;Training Data&quot;], [test_df, &quot;Test Data&quot;], &quot;Survived&quot;, feature_config) 比较同一数据帧的两个子集（例如，男性与女性）另一种获得深刻见解的方法是使用比较功能将您的数据集分为2个子种群。 通过compare_intra（）函数可以将您的数据集分为2个子集并进行比较。 My_report = sv.compare_intra（my_dataframe，my_dataframe [“ Sex”] ==“ male”，[“ Male”，“ Female”]，feature_config） 目前这个包还处于开发版本，还是存在很多的不足的地方，比如无法拉动网页界面，中文数据集会出现乱码等等。不过目前来看还是一个很不错的EDA工具","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Python包","slug":"Python包","permalink":"http://smilecoc.vip/tags/Python包/"}],"author":"smilecoc"},{"title":"Faker库：快速生成测试数据","slug":"Faker库","date":"2020-07-20T15:57:14.629Z","updated":"2020-07-20T16:04:41.952Z","comments":true,"path":"2020/07/20/Faker库/","link":"","permalink":"http://smilecoc.vip/2020/07/20/Faker库/","excerpt":"","text":"在做程序开发的时候，我们经常会用到一些测试数据.在 Python 中有个神库，叫做 Faker，它可以自动帮我们来生成各种各样的看起来很真的”假“数据，让我们来看看吧！ 安装首先让我们来看看这个库的安装方法，实际上装起来非常简单，使用 pip 安装即可，Python3 版本的安装命令如下： pip3 install faker 安装好了之后，我们使用最简单的例子来生成几个假数据试试： from faker import Faker faker = Faker() print(&#39;name:&#39;, faker.name()) print(&#39;address:&#39;, faker.address()) print(&#39;text:&#39;, faker.text()) 首先我们从 faker 这个包里面导入一个 Faker 类，然后将其实例化为 faker 对象，依次调用它的 name、address、text 方法，看下运行效果： name: Nicholas Wilson address: 70561 Simmons Road Apt. 893 Lake Raymondville, HI 35240 text: Both begin bring federal space. Official start idea specific. Able under young fire. Who show line traditional easy people. Until economic lead event case. Technology college his director style.看到这里给我们生成了看起来很真的英文姓名、地址、长文本。 但我们是中国人，我们肯定想要生成中文的吧，不用担心，这个库对非常多的语言都有支持，当然也包括中文了，具体的支持的语言列表可以见：https://faker.readthedocs.io/en/master/locales.html。 这里几个比较常见的语言代号列一下： 简体中文：zh_CN 繁体中文：zh_TW 美国英文：en_US 英国英文：en_GB 德文：de_DE 日文：ja_JP 韩文：ko_KR 法文：fr_FR那么如果要生成中文，只需要在 Faker 类的第一个参数传入对应的语言代号即可，例如简体中文就传入 zh_CN，所以上面的代码改写如下： from faker import Faker faker = Faker(&#39;zh_CN&#39;) print(&#39;name:&#39;, faker.name()) print(&#39;address:&#39;, faker.address()) print(&#39;text:&#39;, faker.text())运行结果如下： name: 何琳 address: 宁夏回族自治区六盘水县南溪北镇街f座 912311 text: 经营软件积分开始次数专业.美国留言一种管理人民解决两个.支持只有地方一切. 文化目前东西的是不过所以.系统觉得这种为什一下他们.时候以及这样继续是一状态威望. 网站密码情况.问题一点那个还是.其实过程详细. 中国历史环境电话规定.经验上海控制不要生活.朋友运行项目我们. 以后今天那些使用免费国家加入但是.内容简介空间次数最大一个.日期通过得到日本北京.可以看到一段中文的姓名、地址、长文本便生成了。看起来地址是省份、地级市、县级市、街道是随机组合的，文本也是一些随机的词组合而成的，但其实这样已经比文章一开头列的测试数据强太多了。 上面的代码每次运行得到的结果都是不同的，因为生成的结果都是随机组合而成的。 Provider接下来让我们详细看下 faker 可以都生成什么类型的数据，具体的可用 API 可以看 https://faker.readthedocs.io/en/master/locales/zh_CN.html，这里面列出来了可用的所有方法。 但打开之后可以发现，这里面多了一个 Provider 对象，那么这个 Provider 是怎么一回事呢？ 实际上这个 faker 库在设计上，为了解耦，将 Provider 对象做成了 Faker 对象的”插件“。Faker 可以添加一个个 Provider 对象，Provider 对象为 Faker 对象提供了生成某项数据的核心实现。就相当于 Faker 对象是一个生成器，它的生成功能依赖于什么呢？依赖于 Provider，是 Provider 提供给了 Faker 对象生成某项数据的能力。 正是因为 Faker 对象内置了一些 Provider 对象，Faker 对象才可以生成刚才所要求的姓名、地址和文本。 那么这时候我们肯定就很好奇了，既然 Faker 对象有生成数据的能力，那么它一定内置了一些默认的 Provider 对象，下面我们来打印看一下： from faker import Faker faker = Faker(&#39;zh_CN&#39;) print(faker.providers) 运行结果如下： [&lt;faker.providers.user_agent.Provider object at 0x10249de48&gt;, &lt;faker.providers.ssn.zh_CN.Provider object at 0x10249dc18&gt;, &lt;faker.providers.python.Provider object at 0x10249dd68&gt;, &lt;faker.providers.profile.Provider object at 0x10249dcc0&gt;, &lt;faker.providers.phone_number.zh_CN.Provider object at 0x10249dc88&gt;, &lt;faker.providers.person.zh_CN.Provider object at 0x10249de80&gt;, &lt;faker.providers.misc.Provider object at 0x10249df60&gt;, &lt;faker.providers.lorem.zh_CN.Provider object at 0x10249dc50&gt;, &lt;faker.providers.job.zh_CN.Provider object at 0x10249de10&gt;, &lt;faker.providers.isbn.Provider object at 0x10249c6d8&gt;, &lt;faker.providers.internet.zh_CN.Provider object at 0x10249c828&gt;, &lt;faker.providers.geo.en_US.Provider object at 0x102484748&gt;, &lt;faker.providers.file.Provider object at 0x102484828&gt;, &lt;faker.providers.date_time.en_US.Provider object at 0x1023789e8&gt;, &lt;faker.providers.currency.Provider object at 0x102484780&gt;, &lt;faker.providers.credit_card.Provider object at 0x1024845f8&gt;, &lt;faker.providers.company.zh_CN.Provider object at 0x102499ef0&gt;, &lt;faker.providers.color.en_US.Provider object at 0x1023532e8&gt;, &lt;faker.providers.barcode.Provider object at 0x101cb6d30&gt;, &lt;faker.providers.bank.en_GB.Provider object at 0x102378f98&gt;, &lt;faker.providers.automotive.en_US.Provider object at 0x1017a5c50&gt;, &lt;faker.providers.address.zh_CN.Provider object at 0x101787c18&gt;]还真不少，通过名字可以看到有 user_agent、phone_number、isbn、credit_card 等 Provider，其中具有语言差异化的 Provider 还单独区分了语言，比如 phone_number 代表电话号码，这个不同语言的不同，所以这里就又分了一层 zh_CN，作了语言的区分。 这样一来，通用的 Provider 就直接处在某个 Provider 类别的模块中，具有语言差异的 Provider 就又根据不同的语言进一步划分了模块，设计上非常科学，易扩展又不冗余。 知道了 Faker 具有这么多 Provider 之后，我们来看看刚才调用的 name、address 等方法又和 Provider 有什么关系呢？ 我们将 name、address、text 等方法打印一下看看： from faker import Faker faker = Faker(&#39;zh_CN&#39;) print(&#39;name:&#39;, faker.name) print(&#39;address:&#39;, faker.address) print(&#39;text:&#39;, faker.text) 注意这里没有调用，而是直接打印了这三个方法，这样可以直接输出方法的对象形式的描述，结果如下： name: &lt;bound method Provider.name of &lt;faker.providers.person.zh_CN.Provider object at 0x10f6dea58&gt;&gt; address: &lt;bound method Provider.address of &lt;faker.providers.address.zh_CN.Provider object at 0x10e9e6cf8&gt;&gt; text: &lt;bound method Provider.text of &lt;faker.providers.lorem.zh_CN.Provider object at 0x10f6dfda0&gt;&gt;恍然大悟，原来我们调用的方法就是 Faker 对象调用的 Provider 里面的对应方法，比如 name 就是 faker.providers.person.zh_CN.Provider 里面的 name 方法，二者是一致的，我们扒一扒源码验证下，源码在：https://github.com/joke2k/faker/blob/master/faker/providers/person/_init_.py，果不其然，里面定义了 name 方法，然后 Faker 动态地将这个方法引入进来了，就可以使用了。 方法列举既然有这么多 Provider，下面我们再详细地看看还有哪些常用的方法吧，下面进行一部分简单的梳理，参考来源文档地址为：https://faker.readthedocs.io/en/master/providers.html。 AddressAddress，用于生成一些和地址相关的数据，如地址、城市、邮政编码、街道等内容， 用法如下： faker.address() # &#39;新疆维吾尔自治区杰县南湖武汉街D座 253105&#39; faker.building_number() # &#39;B座&#39; faker.city() # &#39;璐县&#39; faker.city_name() # &#39;贵阳&#39; faker.city_suffix() # &#39;县&#39; faker.country() # &#39;阿拉斯加&#39; faker.country_code(representation=&quot;alpha-2&quot;) # &#39;CR&#39; faker.district() # &#39;西峰&#39; faker.postcode() # &#39;726749&#39; faker.province() # &#39;福建省&#39; faker.street_address() # &#39;余路N座&#39; faker.street_name() # &#39;李路&#39; faker.street_suffix() # &#39;路&#39; ColorColor，用于生成和颜色相关的数据，如 HEX、RGB、RGBA 等格式的颜色，用法如下： faker.color_name() # &#39;DarkKhaki&#39; faker.hex_color() # &#39;#97d14e&#39; faker.rgb_color() # &#39;107,179,51&#39; faker.rgb_css_color() # &#39;rgb(20,46,70)&#39; faker.safe_color_name() # &#39;navy&#39; faker.safe_hex_color() # &#39;#dd2200&#39; CompanyCompany，用于生成公司相关数据，如公司名、公司前缀、公司后缀等内容，用法如下： faker.bs() # &#39;grow rich initiatives&#39; faker.catch_phrase() # &#39;Self-enabling encompassing function&#39; faker.company() # &#39;恒聪百汇网络有限公司&#39; faker.company_prefix() # &#39;晖来计算机&#39; faker.company_suffix() # &#39;信息有限公司&#39; Credit Card Credit Card，用于生成信用卡相关数据，如过期时间、银行卡号、安全码等内容，用法如下： faker.credit_card_expire(start=&quot;now&quot;, end=&quot;+10y&quot;, date_format=&quot;%m/%y&quot;) # &#39;08/20&#39; faker.credit_card_full(card_type=None) # &#39;Mastercard\\n玉兰 范\\n5183689713096897 01/25\\nCVV: 012\\n&#39; faker.credit_card_number(card_type=None) # &#39;4009911097184929918&#39; faker.credit_card_provider(card_type=None) # &#39;JCB 15 digit&#39; faker.credit_card_security_code(card_type=None) # &#39;259&#39; Date TimeDate Time，用于生成时间相关数据，如年份、月份、星期、出生日期等内容，可以返回 datetime 类型的数据，用法如下： faker.am_pm() # &#39;AM&#39; faker.century() # &#39;X&#39; faker.date(pattern=&quot;%Y-%m-%d&quot;, end_datetime=None) # &#39;1997-06-16&#39; faker.date_between(start_date=&quot;-30y&quot;, end_date=&quot;today&quot;) # datetime.date(2000, 8, 30) faker.date_between_dates(date_start=None, date_end=None) # datetime.date(2019, 7, 30) faker.date_object(end_datetime=None) # datetime.date(1978, 3, 12) faker.date_of_birth(tzinfo=None, minimum_age=0, maximum_age=115) # datetime.date(2012, 6, 3) faker.date_this_century(before_today=True, after_today=False) # datetime.date(2011, 6, 12) faker.date_this_decade(before_today=True, after_today=False) # datetime.date(2011, 8, 22) faker.date_this_month(before_today=True, after_today=False) # datetime.date(2019, 7, 25) faker.date_this_year(before_today=True, after_today=False) # datetime.date(2019, 7, 22) faker.date_time(tzinfo=None, end_datetime=None) # datetime.datetime(2018, 8, 11, 22, 3, 34) faker.date_time_ad(tzinfo=None, end_datetime=None, start_datetime=None) # datetime.datetime(1566, 8, 26, 16, 25, 30) faker.date_time_between(start_date=&quot;-30y&quot;, end_date=&quot;now&quot;, tzinfo=None) # datetime.datetime(2015, 1, 31, 4, 14, 10) faker.date_time_between_dates(datetime_start=None, datetime_end=None, tzinfo=None) # datetime.datetime(2019, 7, 30, 17, 51, 44) faker.date_time_this_century(before_now=True, after_now=False, tzinfo=None) # datetime.datetime(2002, 9, 25, 23, 59, 49) faker.date_time_this_decade(before_now=True, after_now=False, tzinfo=None) # datetime.datetime(2010, 5, 25, 20, 20, 52) faker.date_time_this_month(before_now=True, after_now=False, tzinfo=None) # datetime.datetime(2019, 7, 19, 18, 4, 6) faker.date_time_this_year(before_now=True, after_now=False, tzinfo=None) # datetime.datetime(2019, 3, 15, 11, 4, 18) faker.day_of_month() # &#39;04&#39; faker.day_of_week() # &#39;Monday&#39; faker.future_date(end_date=&quot;+30d&quot;, tzinfo=None) # datetime.date(2019, 8, 12) faker.future_datetime(end_date=&quot;+30d&quot;, tzinfo=None) # datetime.datetime(2019, 8, 24, 2, 59, 4) faker.iso8601(tzinfo=None, end_datetime=None) # &#39;1987-07-01T18:33:56&#39; faker.month() # &#39;11&#39; faker.month_name() # &#39;August&#39; faker.past_date(start_date=&quot;-30d&quot;, tzinfo=None) # datetime.date(2019, 7, 25) faker.past_datetime(start_date=&quot;-30d&quot;, tzinfo=None) # datetime.datetime(2019, 7, 18, 22, 46, 51) faker.time(pattern=&quot;%H:%M:%S&quot;, end_datetime=None) # &#39;16:22:30&#39; faker.time_delta(end_datetime=None) # datetime.timedelta(0) faker.time_object(end_datetime=None) # datetime.time(22, 12, 15) faker.time_series(start_date=&quot;-30d&quot;, end_date=&quot;now&quot;, precision=None, distrib=None, tzinfo=None) # &lt;generator object Provider.time_series at 0x7fcbce0604f8&gt; faker.timezone() # &#39;Indian/Comoro&#39; faker.unix_time(end_datetime=None, start_datetime=None) # 1182857626 faker.year() # &#39;1970&#39; FileFile，用于生成文件和文件路径相关的数据，包括文件扩展名、文件路径、MIME_TYPE、磁盘分区等内容，用法如下： faker.file_extension(category=None) # &#39;flac&#39; faker.file_name(category=None, extension=None) # &#39;然后.numbers&#39; faker.file_path(depth=1, category=None, extension=None) # &#39;/关系/科技.mov&#39; faker.mime_type(category=None) # &#39;video/ogg&#39; faker.unix_device(prefix=None) # &#39;/dev/sdd&#39; faker.unix_partition(prefix=None) # &#39;/dev/xvds3&#39; GeoGeo，用于生成和地理位置相关的数据，包括经纬度，时区等等信息，用法如下： faker.coordinate(center=None, radius=0.001) # Decimal(&#39;-114.420686&#39;) faker.latitude() # Decimal(&#39;-9.772541&#39;) faker.latlng() # (Decimal(&#39;-27.0730915&#39;), Decimal(&#39;-5.919460&#39;)) faker.local_latlng(country_code=&quot;US&quot;, coords_only=False) # (&#39;41.47892&#39;, &#39;-87.45476&#39;, &#39;Schererville&#39;, &#39;US&#39;, &#39;America/Chicago&#39;) faker.location_on_land(coords_only=False) # (&#39;12.74482&#39;, &#39;4.52514&#39;, &#39;Argungu&#39;, &#39;NG&#39;, &#39;Africa/Lagos&#39;) faker.longitude() # Decimal(&#39;40.885895&#39;) InternetInternet，用于生成和互联网相关的数据，包括随机电子邮箱、域名、IP 地址、URL、用户名、后缀名等内容，用法如下： faker.ascii_company_email(*args, **kwargs) # &#39;xuna@xiaqian.cn&#39; faker.ascii_email(*args, **kwargs) # &#39;min59@60.cn&#39; faker.ascii_free_email(*args, **kwargs) # &#39;min75@gmail.com&#39; faker.ascii_safe_email(*args, **kwargs) # &#39;cliu@example.com&#39; faker.company_email(*args, **kwargs) # &#39;ilong@99.cn&#39; faker.domain_name(levels=1) # &#39;xiulan.cn&#39; faker.domain_word(*args, **kwargs) # &#39;luo&#39; faker.email(*args, **kwargs) # &#39;maoxiulan@hotmail.com&#39; faker.free_email(*args, **kwargs) # &#39;yanshen@gmail.com&#39; faker.free_email_domain(*args, **kwargs) # &#39;yahoo.com&#39; faker.hostname(*args, **kwargs) # &#39;lt-18.pan.cn&#39; faker.image_url(width=None, height=None) # &#39;https://placekitten.com/51/201&#39; faker.ipv4(network=False, address_class=None, private=None) # &#39;192.233.68.5&#39; faker.ipv4_network_class() # &#39;a&#39; faker.ipv4_private(network=False, address_class=None) # &#39;10.9.97.93&#39; faker.ipv4_public(network=False, address_class=None) # &#39;192.51.22.7&#39; faker.ipv6(network=False) # &#39;de57:9c6f:a38c:9864:10ec:6442:775d:5f02&#39; faker.mac_address() # &#39;99:80:5c:ab:8c:a9&#39; faker.safe_email(*args, **kwargs) # &#39;tangjuan@example.net&#39; faker.slug(*args, **kwargs) # &#39;&#39; faker.tld() # &#39;cn&#39; faker.uri() # &#39;http://fangfan.org/app/tag/post/&#39; faker.uri_extension() # &#39;.php&#39; faker.uri_page() # &#39;about&#39; faker.uri_path(deep=None) # &#39;app&#39; faker.url(schemes=None) # &#39;http://mingli.cn/&#39; faker.user_name(*args, **kwargs) # &#39;jie54&#39; Job Job，用于生成和职业相关的数据，用法如下： faker.job() # &#39;烫工&#39; LoremLorem，用于生成一些假文字数据，包括句子、自然段、长文本、关键词等，另外可以传入不同的参数来控制生成的长度，用法如下： faker.paragraph(nb_sentences=3, variable_nb_sentences=True, ext_word_list=None) # &#39;包括的是报告那些一点.图片地址基本全部.&#39; faker.paragraphs(nb=3, ext_word_list=None) # [ &#39;计划规定这样所以组织商品其中.参加成为不同发表地区.精华科技谢谢大家需要.一下手机上海中文工程.&#39;, # &#39;非常相关是一就是一个一种文章发生.增加那些以及之后以下你的.&#39;, # &#39;学生应该出来分析增加关系组织.评论来源朋友注册应该需要单位.感觉最后无法发现选择人民.&#39;] faker.sentence(nb_words=6, variable_nb_words=True, ext_word_list=None) # &#39;介绍结果自己解决处理.&#39; faker.sentences(nb=3, ext_word_list=None) # [&#39;查看其实一次学习登录浏览是一他们.&#39;, &#39;而且资源的人事情.&#39;, &#39;科技价格免费大学教育.&#39;] faker.text(max_nb_chars=200, ext_word_list=None) # (&#39;只是当前国内中文所以.威望系统在线虽然.\\n&#39; # &#39;图片人民非常合作这种谢谢更新.名称详细直接社会一直首页完全.\\n&#39; # &#39;重要更多只要市场.必须只是学生音乐.系统美国类别这些一切环境.\\n&#39; # &#39;但是的话人民美国关于.\\n&#39; # &#39;情况专业国际看到研究.音乐环境市场搜索发现.\\n&#39; # &#39;工具还是到了今天位置人民.留言作者品牌工程项目必须.上海精华现在我们新闻应该关系.\\n&#39; # &#39;更新经济能力全部资源如果.手机能够登录国内.&#39;) faker.texts(nb_texts=3, max_nb_chars=200, ext_word_list=None) # [ &#39;成功可能推荐你的行业.地区而且推荐.\\n&#39; # &#39;网络不断是一主要必须.开始安全服务.\\n&#39; # &#39;应该网上通过以后通过大学.管理要求有关国际阅读当前.为了应该结果点击公司开始怎么.\\n&#39; # &#39;成功一次最大生产网站.这种加入她的地址有限.\\n&#39; # &#39;根据新闻汽车起来非常主题显示必须.有些建设来自作者电话支持.\\n&#39; # &#39;只是资源还是由于经济事情喜欢.为什中文大小得到服务.网络密码是否免费参加一次社区欢迎.&#39;, # &#39;部门活动技术.商品影响发生行业密码完成.就是部门结果资料学习当然.或者帮助城市要求首页市场教育你们.\\n&#39; # &#39;专业完全分析处理城市大学什么.\\n&#39; # &#39;文件非常国际全部起来积分公司.资料的是电影没有.这是本站需要.\\n&#39; # &#39;合作重要没有现在市场开发空间.您的会员推荐成功教育进行中国.\\n&#39; # &#39;文件不是如果评论.因为经验设备规定.\\n&#39; # &#39;加入一起影响网上大家运行在线如果.工程企业这种以后.&#39;, # &#39;空间市场出现必须基本电话.显示一个标准其他设计作品.工程不断新闻问题更多更新这么.\\n&#39; # &#39;一起简介网上内容不会.任何知道各种两个.类别事情经营那么投资市场.\\n&#39; # &#39;那些使用介绍公司朋友人民你们浏览.应该表示一点一般说明主要谢谢.电话回复起来经验一个来源加入.\\n&#39; # &#39;地区法律其他表示虽然.参加社会喜欢有限论坛一般发布.类别目前文化可以.\\n&#39; # &#39;报告质量工作主要.企业发布完全.得到名称作者等级两个论坛只要电话.&#39;] faker.word(ext_word_list=None) # &#39;注意&#39; faker.words(nb=3, ext_word_list=None, unique=False) # [&#39;责任&#39;, &#39;组织&#39;, &#39;以后&#39;]在这里每个方法的参数是不同的，具体的参数解释可以见源代码每个方法的注释：https://github.com/joke2k/faker/blob/master/faker/providers/lorem/__init\\__.py， MiscMisc，用于生成生成一些混淆数据，比如密码、sha1、sha256、md5 等加密后的内容，用法如下： faker.boolean(chance_of_getting_true=50) # True faker.md5(raw_output=False) # &#39;3166fa26ffd3f2a33e020dfe11191ac6&#39; faker.null_boolean() # False faker.password(length=10, special_chars=True, digits=True, upper_case=True, lower_case=True) # &#39;W7Ln8La@%O&#39; faker.sha1(raw_output=False) # &#39;c8301a2a79445439ee5287f38053e4b3a05eac79&#39; faker.sha256(raw_output=False) # &#39;1e909d331e20cf241aaa2da894deae5a3a75e5cdc35c053422d9b8e7ccfa0402&#39; faker.uuid4(cast_to=&lt;class &#39;str&#39;&gt;) # &#39;6e6fe387-6877-48d9-94ea-4263c4c71aa5&#39; PersonPerson，用于生成和人名相关的数据，包括姓氏、名字、全名、英文名等内容，还能区分男女名字，用法如下： faker.first_name() # &#39;颖&#39; faker.first_name_female() # &#39;芳&#39; faker.first_name_male() # &#39;利&#39; faker.first_romanized_name() # &#39;Jing&#39; faker.last_name() # &#39;温&#39; faker.last_name_female() # &#39;寇&#39; faker.last_name_male() # &#39;陈&#39; faker.last_romanized_name() # &#39;Lei&#39; faker.name() # &#39;黄明&#39; faker.name_female() # &#39;张凯&#39; faker.name_male() # &#39;黄鹏&#39; User-AgentUser-Agent，用于生成和浏览器 User-Agent 相关的内容，可以定制各种浏览器，还可以传入版本信息来控制生成的内容，用法如下： faker.chrome(version_from=13, version_to=63, build_from=800, build_to=899) # (&#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/5332 (KHTML, like Gecko) &#39; # &#39;Chrome/40.0.837.0 Safari/5332&#39;) faker.firefox() # (&#39;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_8_9; rv:1.9.4.20) &#39; # &#39;Gecko/2019-05-02 05:58:44 Firefox/3.6.19&#39;) faker.internet_explorer() # &#39;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/3.0)&#39; faker.linux_platform_token() # &#39;X11; Linux i686&#39; faker.linux_processor() # &#39;x86_64&#39; faker.mac_platform_token() # &#39;Macintosh; U; PPC Mac OS X 10_12_5&#39; faker.mac_processor() # &#39;U; Intel&#39; faker.opera() # &#39;Opera/9.77.(Windows NT 4.0; vi-VN) Presto/2.9.182 Version/11.00&#39; faker.safari() # (&#39;Mozilla/5.0 (Macintosh; PPC Mac OS X 10_7_1 rv:5.0; or-IN) &#39; # &#39;AppleWebKit/535.9.4 (KHTML, like Gecko) Version/5.0.2 Safari/535.9.4&#39;) faker.user_agent() # &#39;Opera/8.69.(X11; Linux i686; ml-IN) Presto/2.9.170 Version/11.00&#39; faker.windows_platform_token() # &#39;Windows NT 6.1&#39; 以上仅仅列了一部分，还有更多的功能大家可以查看官方文档的内容，链接为：https://faker.readthedocs.io/en/master/locales/zh_CN.html。 其他 Provider另外还有一些社区贡献的 Provider，如 WiFi、微服务相关的，大家可以查看文档的说明，另外需要额外安装这些扩展包并自行添加 Provider，文档见：https://faker.readthedocs.io/en/master/communityproviders.html。 添加 Provider 需要调用 add_provider 方法，用法示例如下： from faker import Faker from faker.providers import internet faker = Faker() faker.add_provider(internet) print(faker.ipv4_private()) 还有更多的内容大家可以参考官方文档，链接：https://faker.readthedocs.io/。","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Python库","slug":"Python库","permalink":"http://smilecoc.vip/tags/Python库/"}],"author":"smilecoc"},{"title":"removebg包：一键抠图&换证件照底色","slug":"removebg库","date":"2020-07-13T03:52:14.000Z","updated":"2020-07-20T16:05:49.160Z","comments":true,"path":"2020/07/13/removebg库/","link":"","permalink":"http://smilecoc.vip/2020/07/13/removebg库/","excerpt":"","text":"Remove.bg是一个利用AI智能抠图的网站，在这个网站上可以上传图片，然后实现自动抠图并更换背景等，如果不懂编程的可以直接登陆https://www.remove.bg/zh操作 Remove.bg 网站提供了API 接口，可以直接调用并实现抠图。而在python中已经有基于api开发的removebg包，可以非常方便的实现相关功能 首先安装removebg包： pip install removebg 然后需要一个Remove.bg 网站的API-key.需要登录Remove.bg的官网并注册。注册完成后可以在“我的账户”中查看API-key。复制这个key即可 之后就可以使用remove_background_from_img_file函数快速转化图片的背景了： from removebg import RemoveBg rmbg = RemoveBg(&quot;YOUR-API-KEY&quot;, &quot;error.log&quot;) rmbg.remove_background_from_img_file(&quot;testrmbg.jpg&quot;) 语法为：remove_background_from_img_file（img_file_path，size，bg_color），参数如下图所示： 例如要将证件照背景换为白色底色，并且输出4k分辨率的图片 from removebg import RemoveBg rmbg = RemoveBg(&quot;YOUR-API-KEY&quot;, &quot;error.log&quot;) rmbg.remove_background_from_img_file(&quot;identificationphoto.jpg&quot;,&#39;4k&#39;,&#39;blank&#39;) 同时我们也可以实现照片的批量转换： from removebg import RemoveBg import os rmbg = RemoveBg(&quot;YOUR-API-KEY&quot;, &quot;error.log&quot;) #os.getcwd() 方法用于返回当前工作目录 #同时将生成的结果放在路径中的picture文件夹中 path=&#39;%s/picture&#39;%os.getcwd() print(path) for pic in os.listdir(path): #os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。 rmbg.remove_background_from_img_file(&#39;%s\\%s&#39;%(path,pic)) 需要注意的是免费用户系统会自动赠送你一个credit以及50次的免费预览。免费预览就是低像素（最高 25 万像素，例如625 × 400 像素）的抠图，想要获得高像素图像就需要花费credit。所以用完了之后就会拒绝你的api请求. 另外此包还支持修改url图片背景remove_background_from_img_url（）和base64图片remove_background_from_base64_img（） 最后附上removebg包的github地址：https://github.com/brilam/remove-bg 官网API文档：https://www.remove.bg/zh/api 本文首发于博客：http://smilecoc.vip/微信公众号：Romi的杂货铺","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Python包","slug":"Python包","permalink":"http://smilecoc.vip/tags/Python包/"}],"author":"smilecoc"},{"title":"一张图彻底搞懂 MySQL 的锁机制","slug":"SQL锁","date":"2020-07-09T04:25:18.000Z","updated":"2020-07-08T17:04:22.676Z","comments":true,"path":"2020/07/09/SQL锁/","link":"","permalink":"http://smilecoc.vip/2020/07/09/SQL锁/","excerpt":"","text":"简介锁在MySQL中是非常重要的一部分，锁对MySQL的数据访问并发有着举足轻重的影响。锁涉及到的知识篇幅也很多，所以要啃完并消化到自己的肚子里，是需要静下心好好反反复复几遍地细细品味。本文是对锁的一个大概的整理，一些相关深入的细节，还是需要找到相关书籍来继续夯实。 一张图了解 MySQL 锁 锁的认识1.1 锁的解释计算机协调多个进程或线程并发访问某一资源的机制。 1.2 锁的重要性在数据库中，除传统计算资源（CPU、RAM、I\\O等）的争抢，数据也是一种供多用户共享的资源。如何保证数据并发访问的一致性，有效性，是所有数据库必须要解决的问题。锁冲突也是影响数据库并发访问性能的一个重要因素，因此锁对数据库尤其重要。 1.3 锁的缺点加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等 ，都会增加系统的开销。 1.4 简单的例子现如今网购已经特别普遍了，比如淘宝双十一活动，当天的人流量是千万及亿级别的，但商家的库存是有限的。系统为了保证商家的商品库存不发生超卖现象，会对商品的库存进行锁控制。当有用户正在下单某款商品最后一件时，系统会立马对该件商品进行锁定，防止其他用户也重复下单，直到支付动作完成才会释放（支付成功则立即减库存售罄，支付失败则立即释放）。 锁的类型2.1 表锁种类 读锁（read lock），也叫共享锁（shared lock）。针对同一份数据，多个读操作可以同时进行而不会互相影响（select） 写锁（write lock），也叫排他锁（exclusive lock）。当前操作没完成之前，会阻塞其它读和写操作（update、insert、delete） 存储引擎默认锁MyISAM 特点 对整张表加锁 开销小 加锁快 无死锁 锁粒度大，发生锁冲突概率大，并发性低 结论 读锁会阻塞写操作，不会阻塞读操作 写锁会阻塞读和写操作 建议MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎，因为写锁以后，其它线程不能做任何操作，大量的更新使查询很难得到锁，从而造成永远阻塞。 2.2 行锁种类 读锁（read lock），也叫共享锁（shared lock）。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁 写锁（write lock），也叫排他锁（exclusive lock）。允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享锁和排他锁 意向共享锁（IS），一个事务给一个数据行加共享锁时，必须先获得表的IS锁 意向排它锁（IX），一个事务给一个数据行加排他锁时，必须先获得该表的IX锁 存储引擎默认锁InnoDB 特点 对一行数据加锁 开销大 加锁慢 会出现死锁 锁粒度小，发生锁冲突概率最低，并发性高 事务并发带来的问题 更新丢失解决：让事务变成串行操作，而不是并发的操作，即对每个事务开始—对读取记录加排他锁 脏读解决：隔离级别为Read uncommitted 不可重读解决：使用Next-Key Lock算法来避免 幻读解决：间隙锁（Gap Lock） 2.3 页锁开销、加锁时间和锁粒度介于表锁和行锁之间，会出现死锁，并发处理能力一般（此锁不做多介绍） 如何上锁？3.1 表锁隐式上锁（默认，自动加锁自动释放）select //上读锁insert、update、delete //上写锁 显式上锁（手动）lock table tableName read;//读锁 lock table tableName write;//写锁解锁（手动）unlock tables;//所有锁表 session01 session02 lock table teacher read;//上读锁 select * from teacher; //可以正常读取 select * from teacher;//可以正常读取 update teacher set name = 3 where id =2;//报错因被上读锁不能写操作 update teacher set name = 3 where id =2;//被阻塞 unlock tables;//解锁 - update teacher set name = 3 where id =2;//更新操作成功 session01 session02 lock table teacher write;//上写锁 select * from teacher; //可以正常读取 select * from teacher;//被阻塞 update teacher set name = 3 where id =2;//可以正常更新操作 update teacher set name = 4 where id =2;//被阻塞 unlock tables;//解锁 &ensp; select * from teacher;//读取成功 &ensp; update teacher set name = 4 where id =2;//更新操作成功 3.2 行锁隐式上锁（默认，自动加锁自动释放）select //不会上锁insert、update、delete //上写锁 显式上锁（手动）select * from tableName lock in share mode;//读锁 select * from tableName for update;//写锁解锁（手动） 提交事务（commit） 回滚事务（rollback） kill 阻塞进程 session01 session02 begin; select * from teacher where id = 2 lock in share mode;//上读锁 &ensp; select * from teacher where id = 2;//可以正常读取 update teacher set name = 3 where id =2;// 可以更新操作 update teacher set name = 5 where id =2;//被阻塞 commit; &ensp; update teacher set name = 5 where id =2;//更新操作成功 session01 session02 begin; select * from teacher where id = 2 for update;//上写锁 &ensp; select * from teacher where id = 2;//可以正常读取 update teacher set name = 3 where id =2;// 可以更新操作 update teacher set name = 5 where id =2;//被阻塞 rollback; &ensp; update teacher set name = 5 where id =2;//更新操作成功 为什么上了写锁，别的事务还可以读操作？因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。 行锁的实现算法4.1 Record Lock锁单个行记录上的锁Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表建立的时候没有设置任何一个索引，这时InnoDB存储引擎会使用隐式的主键来进行锁定 4.2 Gap Lock锁当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引加锁，对于键值在条件范围内但并不存在的记录。 优点：解决了事务并发的幻读问题不足：因为query执行过程中通过范围查找的话，他会锁定争个范围内所有的索引键值，即使这个键值并不存在。 间隙锁有一个致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成锁定的时候无法插入锁定键值范围内任何数据。在某些场景下这可能会对性能造成很大的危害。 4.3 Next-key Lock锁同时锁住数据+间隙锁在Repeatable Read隔离级别下，Next-key Lock 算法是默认的行记录锁定算法。 4.4 行锁的注意点 只有通过索引条件检索数据时，InnoDB才会使用行级锁，否则会使用表级锁(索引失效，行锁变表锁) 即使是访问不同行的记录，如果使用的是相同的索引键，会发生锁冲突 如果数据表建有多个索引时，可以通过不同的索引锁定不同的行 如何排查锁？5.1 表锁查看表锁情况show open tables; 表锁分析show status like &#39;table%&#39;; table_locks_waited出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次值加1），此值高说明存在着较严重的表级锁争用情况 table_locks_immediate产生表级锁定次数，不是可以立即获取锁的查询次数，每立即获取锁加1 5.2 行锁行锁分析show status like &#39;innodb_row_lock%&#39;; innodb_row_lock_current_waits //当前正在等待锁定的数量 innodb_row_lock_time //从系统启动到现在锁定总时间长度 innodb_row_lock_time_avg //每次等待所花平均时间 innodb_row_lock_time_max //从系统启动到现在等待最长的一次所花时间 innodb_row_lock_waits //系统启动后到现在总共等待的次数 information_schema库 innodb_lock_waits表 innodb_locks表 innodb_trx表 优化建议 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 合理设计索引，尽量缩小锁的范围 尽可能较少检索条件，避免间隙锁 尽量控制事务大小，减少锁定资源量和时间长度 尽可能低级别事务隔离 死锁6.1 解释指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象 6.2 产生的条件 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在没有使用完之前，不能强行剥夺 循环等待条件：多个进程之间形成的一种互相循环等待的资源的关系 6.3 解决 查看死锁：show engine innodb status \\G 自动检测机制，超时自动回滚代价较小的事务（innodb_lock_wait_timeout 默认50s） 人为解决，kill阻塞进程（show processlist） wait for graph 等待图（主动检测） 6.4 如何避免 加锁顺序一致，尽可能一次性锁定所需的数据行 尽量基于primary（主键）或unique key更新数据 单次操作数据量不宜过多，涉及表尽量少 减少表上索引，减少锁定资源 尽量使用较低的隔离级别 尽量使用相同条件访问数据，这样可以避免间隙锁对并发的插入影响 精心设计索引，尽量使用索引访问数据 借助相关工具：pt-deadlock-logger 乐观锁与悲观锁 7.1 悲观锁解释假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 实现机制表锁、行锁等 实现层面数据库本身 适用场景并发量大 7.2 乐观锁解释假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性 实现机制提交更新时检查版本号或者时间戳是否符合 实现层面业务代码 适用场景并发量小 原文地址：https://developer.aliyun.com/article/741811","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"SQL server中的模式架构schema详解","slug":"SQL  server中的模式架构schema详解","date":"2020-06-23T15:33:33.000Z","updated":"2020-07-08T16:26:18.325Z","comments":true,"path":"2020/06/23/SQL  server中的模式架构schema详解/","link":"","permalink":"http://smilecoc.vip/2020/06/23/SQL  server中的模式架构schema详解/","excerpt":"","text":"sql server 中的模式/架构（schema）SQL Server中模式（schema）这个概念是在2005的版本里才提出来的，因此SQL Server2000不支持模式这个概念 模式又称架构，架构的定义是形成单个命名空间的数据库实体的集合。命名空间是一个集合，其中每个元素的名称都是唯一的。在这里，我们可以将架构看成一个存放数据库中对象的一个容器。 上面的文字描述过于晦涩，举个简单的例子，平时要在电脑硬盘存放东西时，我们不会把所有的东西都存在一个文件夹里，而是会把不同的文件按照某一个标准分门别类，放到不同的文件夹里。而在数据库中，起到这个作用的就是架构，数据库对象（表、视图、存储过程，触发器等）按照一定的标准，存放在不同的架构里。有过java编程经验的同学都知道，命名空间名其实就是文件夹名，因此我们非常明确一点：一个对象只能属于一个架构，就像一个文件只能存放于一个文件夹中一样。与文件夹不同的是，架构是不能嵌套的，如此而已。因此，架构的好处非常明显——便于管理。 举个例子，我们可以把数据库看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，于是乎，在不同的房间里，我们可以放不同的东西——有的放食物，有的放衣物……而这些不同的东西，就对应着我们数据库里的对象。 用户架构分离的好处 架构管理与用户管理分开。多个用户可以通过角色（Role）或组（Windows Groups）成员关系拥有同一个架构。在SQL SERVER 2005/2008 中，每个数据库中的固定数据库角色都有一个属于自己的架构，如果我们创建一个表，给它指定的架构名称为 db_ddladmin，那么任何一个属于db_ddladmin中的用户都是可以去查询、修改和删除属于这个架构中的表，但是不属于这个组的用户是没有对这个架构中的表进行操作的权限。 在创建数据库用户时，可以指定该用户账号所属的默认架构,若不指定默认架构，则为dbo。大多数用户在创建对象的时候习惯直接输入对象名而将对象的架构名称省略，在2005/2008 中，用户如果没有设置自己的默认架构，会给这样创建的对象加上一个缺省的架构dbo，也就是说，如果一个db_ddladmin的成员在数据库中创建一个没有加上架构名称的表，这个表在数据库中的完整名称应该是dbo.表名，创建者在数据库中如果不是属于其它特殊组的成员，是不能对自己创建的表进行任何修改和查询的，那就相当于把自己赚的钱存进了别人的银行卡，自己却取不出来。 删除数据库用户变得极为简单。在 SQL Server 2000 中，用户（User）和架构是隐含关联的，即每个用户拥有与其同名的架构。因此要删除一个用户，必须先删除或修改这个用户所拥有的所有数据库对象。SQL SERVER 2005/2008将架构和对象者分离后就不在存在这样的问题，删除用户的时候不需要重命名该用户架构所包含的对象，在删除创建架构所含对象的用户后，不再需要修改和测试显式引用这些对象的应用程序。 区分不同业务处理需要的对象，例如，我们可以把公共的表设置成Pub的架构，把销售相关的设置为Sales，这样管理和访问起来更容易。 在架构和架构所包含的对象上设置权限（Permissions）比以前的版本拥有更高的可管理性。 当查找对象时，先找与用户默认架构相同的架构下的对象，找不到再找dbo的对象。 sql server 修改表的模式schema创建schema并赋予wang这个用户这个schema的权限 create schema myschema authorization wang; 修改当前表的schema use myDB --使用的数据库 go create schema myschema --如果没有此schema就先建立 go alter schema myschema transfer dbo.myTable --移动对象至建立的schema下 go 删除schema drop schema wang cascade; 其中，CASCADE（级联）表示删除模式的同时把该模式中所有的数据库对象全部删除。同时也可以改为RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"Markdown语法参考","slug":"Markdown语法参考","date":"2020-06-21T05:28:30.000Z","updated":"2020-07-08T16:07:37.664Z","comments":true,"path":"2020/06/21/Markdown语法参考/","link":"","permalink":"http://smilecoc.vip/2020/06/21/Markdown语法参考/","excerpt":"","text":"Markdown 是一种轻量级标记语言,它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。被广泛应用于博客，网页与技术文档中 为什么选择 Markdown 它基于纯文本，方便修改和共享； 几乎可以在所有的文本编辑器中编写； 有众多编程语言的实现，以及应用的相关扩展； 在 GitHub 等网站中有很好的应用； 很容易转换为 HTML 文档或其他格式； 适合用来编写文档、记录笔记、撰写文章。 Markdown 语法段落与换行 段落的前后必须是空行：空行指的是行内什么都没有，或者只有空白符（空格或制表符).相邻两行文本，如果中间没有空行 会显示在一行中（换行符被转换为空格） 如果需要在段落内加入换行（&lt;br&gt;）：可以在前一行的末尾加入至少两个空格,然后换行写其它的文字 Markdown 中的多数区块都需要在两个空行之间。 标题一般用对称的 # 包括文本，或者只在左边使用 #。例如下面的语句： #### 标题4 #### ##### 标题5标题4标题5其中加几个#表示几级标题，在#符号内侧一般会加上空格 引用1. 引用内容在段落或其他内容前使用 &gt; 符号，就可以将这段内容标记为 ‘引用’ 的内容： &gt;引用内容 引用内容 2. 多行引用多行引用可以在每行前加 &gt;,也可以仅在第一行使用 &gt;，后面相邻的行即使省略 &gt;，也会变成引用内容。如果引用内容需要换行， 可以在行尾添加两个空格，或者在引用内容中加一个空行，如下所示： &gt;如果引用内容需要换行， &gt;可以在行尾添加两个空格 &gt; &gt;或者在引用内容中加一个空行列表无序列表* 可以使用 `*` 作为标记 + 也可以使用 `+` - 或者 `-`上述语句的渲染结果为： 可以使用 * 作为标记 也可以使用 + 或者 - 有序列表1. 有序列表以数字和 `.` 开始； 3. 数字的序列并不会影响生成的列表序列； 4. 但仍然推荐按照自然顺序（1.2.3...）编写。上述语句的渲染结果为： 有序列表以数字和 . 开始； 数字的序列并不会影响生成的列表序列； 但仍然推荐按照自然顺序（1.2.3…）编写。 嵌套(多层)列表多层列表在符号或者序号前加上tab即可 1. 第一层 + 1-1 + 1-2 2. 无序列表和有序列表可以随意相互嵌套 1. 2-1 2. 2-2 第一层 1-1 1-2 无序列表和有序列表可以随意相互嵌套 2-1 2-2 代码代码块可以使用缩进来插入代码块，但是一般我们使用 ``````来包含多行代码``` &lt;p&gt;code here&lt;/p&gt;```上述语句的渲染结果为： &lt;p&gt;code here&lt;/p&gt;代码高亮在上面的代码块语法基础上，在第一组 ```之后添加代码的语言，如 ‘javascript’ 或 ‘js’，即可将代码标记为 JavaScript,同时可以将对应代码高亮：```jswindow.addEventListener(‘load’, function() { console.log(‘window loaded’);});``` window.addEventListener(&#39;load&#39;, function() { console.log(&#39;window loaded&#39;); }); Markdown支持的语言与相应关键字有： 名称 关键字 调用的js 说明 AppleScript applescript shBrushAppleScript.js ActionScript 3.0 actionscript3 , as3 shBrushAS3.js Shell bash , shell shBrushBash.js ColdFusion coldfusion , cf shBrushColdFusion.js C cpp , c shBrushCpp.js C# c# , c-sharp , csharp shBrushCSharp.js CSS css shBrushCss.js Delphi delphi , pascal , pas shBrushDelphi.js diff&amp;patch diff patch shBrushDiff.js 用代码版本库时,遇到代码冲突,其语法就是这个. Erlang erl , erlang shBrushErlang.js Groovy groovy shBrushGroovy.js Java java shBrushJava.js JavaFX jfx , javafx shBrushJavaFX.js JavaScript js , jscript , javascript shBrushJScript.js Perl perl , pl , Perl shBrushPerl.js PHP php shBrushPhp.js text text , plain shBrushPlain.js 就是普通文本. Python py , python shBrushPython.js Ruby ruby , rails , ror , rb shBrushRuby.js SASS&amp;SCSS sass , scss shBrushSass.js Scala scala shBrushScala.js SQL sql shBrushSql.js Visual Basic vb , vbnet shBrushVb.js XML xml , xhtml , xslt , html shBrushXml.js Objective C objc , obj-c shBrushObjectiveC.js F# f# f-sharp , fsharp shBrushFSharp.js R r , s , splus shBrushR.js matlab matlab shBrushMatlab.js swift swift shBrushSwift.js GO go , golang shBrushGo.js 上述表格应该包括所有的常使用的代码语言，但肯定不包括所有的语言，如有缺失欢迎指出 分隔线可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线： *** ------ ___ 超链接格式为[link text](URL ‘title text’) [Google](http://www.google.com/)上述语句的渲染结果为：Google 同时也可以创建指向本地文件的链接： [icon.png](./images/icon.png)图像插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 !. ![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;) 强调 使用 * * 或 _ _ 包括的文本会被转换为 &lt;em&gt;&lt;/em&gt; ，通常表现为斜体： 这是用来 *演示* 的 _文本_这是用来 演示 的 文本 使用 ** ** 或 __ __ 包括的文本会被转换为 &lt;strong&gt;&lt;/strong&gt;，通常表现为加粗： 这是用来 **演示** 的 __文本__这是用来 演示 的 文本 用来包括文本的 * 或 _ 内侧不能有空白，否则 * 和 _ 将不会被转换（不同的实现会有不同的表现）： 这是用来 * 演示* 的 _文本 _这是用来 * 演示* 的 _文本 _ 如果需要在文本中显示成对的 * 或 _，可以在符号前加入 (转义字符) 即可： 这是用来 \\*演示\\* 的 \\_文本\\_这是用来 *演示* 的 _文本_ 、*、_ 和 __ 都必须 成对使用 。 Markdown字符转义反斜线（\\）用于插入在 Markdown 语法中有特殊作用的字符。 这是用来 *演示* 的 _文本_ 这是用来 \\*演示\\* 的 \\_文本\\_第一句结果出来的结果为：这是用来 演示 的 文本而第二句的结果为:这是用来 *演示* 的 _文本_ 这些需要转义的字符包括： \\ ` * _ {} [] () # + - . !删除线这就是 ~~删除线~~这就是 删除线 表格单元格和表头使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行： name | age ---- | --- LearnShare | 12 Mike | 32 name age LearnShare 12 Mike 32 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界： | name | age | | ---------- | --- | | LearnShare | 12 | | Mike | 32 | name age LearnShare 12 Mike 32 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 对齐在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： :— 代表左对齐 :–: 代表居中对齐 —: 代表右对齐| left | center | right | | :--- | :----: | ----: | | aaaa | bbbbbb | ccccc | | a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。 在表格单元格里换行借助于 HTML 里的 实现。 示例代码： | Header1 | Header2 | |---------|----------------------------------| | item 1 | 1. one&lt;br /&gt;2. two&lt;br /&gt;3. three |示例效果： Header1 Header2 item 1 1. one2. two3. three 在表格单元格里加入空格直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，&ensp; 代表半角空格，&emsp; 代表全角空格 | Header1 | Header2 | |---------|----------------------------------| | &amp;ensp; | one Header1 Header2 &ensp; one 同理，这个方法可以在任何需要添加空格和缩进的地方使用 任务清单- [ ] Eat - [x] Code - [x] HTML - [x] CSS - [x] JavaScript - [ ] Sleep Eat Code HTML CSS JavaScript Sleep 添加emoji更多可用 Emoji 代码参见 https://www.webpagefx.com/tools/emoji-cheat-sheet/ 我和我的小伙伴们都笑了。:smile:我和我的小伙伴们都笑了。:smile: 图文混排使用 标签来贴图，然后指定 align 属性。 示例代码： &lt;img align=&quot;right&quot; src=&quot;https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;/&gt; 这是一个示例图片。 图片显示在 N 段文字的右边。 N 与图片高度有关。 刷屏行。 刷屏行。 到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 这是一个示例图片。 图片显示在 N 段文字的右边。 N 与图片高度有关。 刷屏行。 刷屏行。 到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 控制图片大小和位置标准的 Markdown 图片标记 无法指定图片的大小和位置，只能依赖默认的图片大小，默认居左。 而有时候源图太大想要缩小一点，或者想将图片居中，就仍需要借助 HTML 的标签来实现了。图片居中可以使用 标签加 align 属性来控制，图片宽高则用 width 和 height 来控制。 示例代码： **图片默认显示效果：** ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL216bG9naW4vbXpsb2dpbi5naXRodWIuaW8vbWFzdGVyL2ltYWdlcy9wb3N0cy9tYXJrZG93bi9kZW1vLnBuZw?x-oss-process=image/format,png) **加以控制后的效果：** &lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;65&quot; height=&quot;75&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL216bG9naW4vbXpsb2dpbi5naXRodWIuaW8vbWFzdGVyL2ltYWdlcy9wb3N0cy9tYXJrZG93bi9kZW1vLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/div&gt;图片默认显示效果： 加以控制后的效果： 文字颜色、大小、字体设置颜色浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字：&lt;/font&gt;&lt;br /&gt; 深红色文字：&lt;font color=&quot;#660000&quot;&gt;深红色文字&lt;/font&gt;&lt;br /&gt; 浅绿色文字：&lt;font color=&quot;#00dd00&quot;&gt;浅绿色文字&lt;/font&gt;&lt;br /&gt; 深绿色文字：&lt;font color=&quot;#006600&quot;&gt;深绿色文字&lt;/font&gt;&lt;br /&gt; 浅蓝色文字：&lt;font color=&quot;#0000dd&quot;&gt;浅蓝色文字&lt;/font&gt;&lt;br /&gt; 深蓝色文字：&lt;font color=&quot;#000066&quot;&gt;深蓝色文字&lt;/font&gt;&lt;br /&gt; 浅黄色文字：&lt;font color=&quot;#dddd00&quot;&gt;浅黄色文字&lt;/font&gt;&lt;br /&gt; 深黄色文字：&lt;font color=&quot;#666600&quot;&gt;深黄色文字&lt;/font&gt;&lt;br /&gt; 浅青色文字：&lt;font color=&quot;#00dddd&quot;&gt;浅青色文字&lt;/font&gt;&lt;br /&gt; 深青色文字：&lt;font color=&quot;#006666&quot;&gt;深青色文字&lt;/font&gt;&lt;br /&gt; 浅紫色文字：&lt;font color=&quot;#dd00dd&quot;&gt;浅紫色文字&lt;/font&gt;&lt;br /&gt; 深紫色文字：&lt;font color=&quot;#660066&quot;&gt;深紫色文字&lt;/font&gt;&lt;br /&gt; 浅红色文字：浅红色文字：深红色文字：深红色文字浅绿色文字：浅绿色文字深绿色文字：深绿色文字浅蓝色文字：浅蓝色文字深蓝色文字：深蓝色文字浅黄色文字：浅黄色文字深黄色文字：深黄色文字浅青色文字：浅青色文字深青色文字：深青色文字浅紫色文字：浅紫色文字深紫色文字：深紫色文字 采用的是RGB颜色这里有个对照：http://www.114la.com/other/rgb.htm可以选择你想要的颜色对应的RGB值。 大小size为1：&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;&lt;br /&gt; size为2：&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;&lt;br /&gt; size为3：&lt;font size=&quot;3&quot;&gt;size为3&lt;/font&gt;&lt;br /&gt; size为4：&lt;font size=&quot;4&quot;&gt;size为4&lt;/font&gt;&lt;br /&gt; size为10：&lt;font size=&quot;10&quot;&gt;size为10&lt;/font&gt;&lt;br /&gt; 效果如下： size为1：size为1size为2：size为2size为3：size为3size为4：size为4size为10：size为10 字体&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;宋体&quot;&gt;我是宋体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑字&lt;/font&gt; &lt;font face=&quot;fantasy&quot;&gt;我是fantasy字&lt;/font&gt; &lt;font face=&quot;Helvetica&quot;&gt;我是Helvetica字&lt;/font&gt;效果如下： 我是黑体字我是宋体字我是微软雅黑字我是fantasy字我是Helvetica字 背景色&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#54FF9F&gt;背景色的设置是按照十六进制颜色值：#54FF9F&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;背景色的设置是按照十六进制颜色值：#7FFFD4 背景色的设置是按照十六进制颜色值：#FF83FA 背景色的设置是按照十六进制颜色值：#D1EEEE 背景色的设置是按照十六进制颜色值：#C0FF3E 背景色的设置是按照十六进制颜色值：#54FF9F 格式化表格表格在渲染之后很整洁好看，但是在文件源码里却可能是这样的： |Header1|Header2| |---|---| |a|a| |ab|ab| |abc|abc|在各种编辑器里有为 Markdown 提供了表格格式化功能，比如我使用 Vim 编辑器，就有 vim-table-mode 插件，它能帮我自动将表格格式化成这样： | Header1 | Header2 | |---------|---------| | a | a | | ab | ab | | abc | abc |是不是看着舒服多了？ 如果你不使用 Vim，也没有关系，比如 Atom 编辑器的 markdown-table-formatter 插件，Sublime Text 3 的 MarkdownTableFormatter 等等，都提供了类似的解决方案。 自动维护目录有时候维护一份比较长的文档，希望能够自动根据文档中的标题生成目录（Table of Contents），并且当标题有变化时自动更新目录，能减轻工作量，也不易出错。 如果你使用 Vim 编辑器，那可以使用插件 vim-markdown-toc 来帮你完美地解决此事： 插件地址：https://github.com/mzlogin/vim-markdown-toc 参考文档：https://mazhuang.org/2017/09/01/markdown-odd-skills/#%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92http://xianbai.me/learn-md/index.html","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://smilecoc.vip/tags/Markdown/"}],"author":"smilecoc"},{"title":"VBA常用代码汇总","slug":"VBA常用代码汇总","date":"2020-06-20T04:36:23.000Z","updated":"2020-07-08T14:58:36.616Z","comments":true,"path":"2020/06/20/VBA常用代码汇总/","link":"","permalink":"http://smilecoc.vip/2020/06/20/VBA常用代码汇总/","excerpt":"","text":"一些日常经常用到的VBA代码汇总 VBA中调用SQL处理数据这里仅提供一个例子，更详细的介绍和使用可参阅http://smilecoc.vip/2020/03/03/VBA%E4%B8%AD%E4%BD%BF%E7%94%A8SQL/ Sub Query() Dim Conn As Object, Rst As Object Dim strConn As String, strSQL As String Dim i As Integer, PathStr As String Set Conn = CreateObject(&quot;ADODB.Connection&quot;) Set Rst = CreateObject(&quot;ADODB.Recordset&quot;) &#39;设置工作簿的完整路径和名称 PathStr = ThisWorkbook.FullName &#39;设置连接字符串,根据Excel版本创建连接 Select Case Application.Version * 1 Case Is &lt;= 11 strConn = &quot;Provider=Microsoft.Jet.Oledb.4.0;Extended Properties=excel 8.0;Data source=&quot; &amp; PathStr Case Is &gt;= 12 strConn = &quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&quot; &amp; PathStr &amp; &quot;;Extended Properties=&quot;&quot;Excel 12.0;HDR=YES&quot;&quot;;&quot;&quot;&quot; End Select &#39; ##########在这里改SQL查询语句 ########## strSQL = &quot;Select distinct Objective,Landing_Site,Publisher,Device,Ad_type,sum(est_impression) as impression,sum(est_click) as click,sum(est_click)/sum(est_impression) as ctr,sum(net_cost)/sum(est_impression)*1000 as cpm,sum(net_cost)/sum(est_click) as cpc FROM [raw data$] group by Objective,Landing_Site,Publisher,Device,Ad_type having Publisher is not null &quot; &#39;打开数据库链接 Conn.Open strConn &#39;执行查询，并将结果输出到记录集对象 Set Rst = Conn.Execute(strSQL) &#39;##########在这里改输出的表名########## With ThisWorkbook.Sheets(&quot;sql data&quot;) .Cells.Clear For i = 0 To Rst.Fields.Count - 1 &#39;填写标题 .Cells(1, i + 1) = Rst.Fields(i).Name Next i &#39;##########在这里改输出的位置与单元格########## .Range(&quot;A2&quot;).CopyFromRecordset Rst .Cells.EntireColumn.AutoFit &#39;自动调整列宽 End With Rst.Close &#39;关闭数据库连接 Conn.Close Set Conn = Nothing Set Rst = Nothing End Sub 插入多行、多列如下的三句vba代码都可以一次插入一行： Cells(2, 1).EntireRow.Insert Rows(2).Insert Range(&quot;2:2&quot;).Insert 插入多列，并添加Insert方法的参数 thisworkbook.sheets(&quot;test&quot;).Columns(&quot;A:A&quot;).Resize(, 5).Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove VBA连接特定的数据库并取数需要注意的是 Provider=sqloledb这一个参数数据库不同的情况下也是不一样的，这里我用的是sql server云数据库，其他的数据库可以另行查找 Uid=用户名称;Pwd=数据库的密码 这两个参数都不是微软账户的名称和密码，否则会报错 Sub getdata_fromdb() Dim Conn As Object, Rst As Object Dim strConn As String, strSQL As String Dim i As Integer, PathStr As String Set Conn = CreateObject(&quot;ADODB.Connection&quot;) Set Rst = CreateObject(&quot;ADODB.Recordset&quot;) PathStr = ThisWorkbook.FullName &#39;设置工作簿的完整路径和名称 strConn = &quot;Provider=sqloledb;Server=数据库服务器地址;Database=数据库名称;Uid=用户名称;Pwd=数据库的密码&quot; &#39;定义数据库链接字符串 &#39;#############################在这里改SQL查询语句 strSQL = &quot;select * from test&quot; Conn.Open strConn Set Rst = Conn.Execute(strSQL) With ThisWorkbook.Sheets(&quot;raw&quot;) .Cells.Clear For i = 0 To Rst.Fields.Count - 1 .Cells(1, i + 1) = Rst.Fields(i).Name Next i .Range(&quot;A2&quot;).CopyFromRecordset Rst .Cells.EntireColumn.AutoFit End With Rst.Close Conn.Close Set Conn = Nothing Set Rst = Nothing MsgBox &quot;数据已更新完成&quot; End Sub 获取最前，后，左，右的行或列&#39;从第一行向左查找到的第一个非空值单元格的列，即最左的一列的列数 Nextcol=Cells(1,columns.count).End(xlToLeft).Column &#39;从第一列的最后一行向上查找到的第一个非空值单元格的行数.End(xlup)，可以简写为end（3） Nextcol=Cells(rows.count,1).End(xlup).row ‘查找最前的行 Nextcol=Cells(1,1).End(xldown).row ‘查找最前的列 Nextcol=Cells(1,1).End(xlright).column &#39;获取当前使用区域的最后一行 ActiveSheet.UsedRange.SpecialCells(xlCellTypeLastCell).Row 选择性粘贴选择性粘贴的语法为： .PasteSpecial(Paste,Operation,SkipBlanks,Transpose)比较常用的几个paste参数为： 公式 xlPasteFormulas 数值 xlPasteValues 格式 xlPasteFormats sqldata.Range(&quot;A2:o&quot; &amp; sqllastrow).Copy Summary.Range(&quot;B9&quot;).PasteSpecial Paste:=xlPasteValues &#39;添加值 用户交互窗口–选择文件弹出用户交互窗口，让用户可以选择.xls;.xlsx;.xlsm格式的文件并打开选择文件 Sub get_mzdata() MsgBox &quot;请选择输入文件&quot; nm = Application.GetOpenFilename(&quot;Excel 文件 ,*.xls*;*.xlsx;*.xlsm&quot;, 4, &quot;选择总表&quot;) If nm = False Then MsgBox &quot;你没有选择文件,程序将结束&quot; Exit Sub End If Set tp = Workbooks.Open(nm) End Sub替换,例如替换AB列里的- Thisworkbook.sheets(&quot;test&quot;).Columns(&quot;AB:AB&quot;).Replace What:=&quot;-&quot;, Replacement:=&quot;/&quot;, LookAt:=xlPart, _ SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _ ReplaceFormat:=False代码分行:如果代码过长的话不利于查看，可以换行书写&#39;对于非sql 语句 可以使用 空格+ _换行，例如 if MsgBox(&quot;您确认要清空文本框值吗?&quot;, vbOKCancel + vbInformation, &quot;提示&quot;) = vbOK Then If MsgBox(&quot;您确认要清空文本框值吗?&quot;, vbOKCancel + _ vbInformation, &quot;提示&quot;) = vbOK Then &#39;对于 sql 语句 可以在句末+双引号+空格+下划线，下一句前面+&amp;+空格+双引号,例如 strsql = &quot;Select 采购订单表.状态, 采购订单表.采购订单号, 采购订单表.采购日期, 采购订单表.供应商ID, 采购订单表.经办人&quot; _ &amp; &quot; FROM 采购订单表;&quot; &#39;也可以这样写： a = &quot;Select 采购订单表.状态, 采购订单表.采购订单号, 采购订单表.采购日期, 采购订单表.供应商ID, 采购订单表.经办人&quot; a = a &amp; &quot; FROM 采购订单表;&quot;去重单列去重 ActiveSheet.Range(&quot;G21:R36&quot;).RemoveDuplicates Columns:=12, Header:=xlYes多列去重 Thisworkbook.Sheets(&quot;test&quot;).Range(&quot;$A:$AL&quot;).RemoveDuplicates Columns:=Array(1, 2, 3, 4, 5, 6, 7, 8, 9), Header:=xlYes当然也可以用字典加数组以及SQL等方式实现去重，会更有效率，这里不在赘述 VBA隐藏与取消隐藏Set raw = ThisWorkbook.Sheets(&quot;raw data&quot;) &#39;取消工作表的全部隐藏 raw.Columns.Hidden = False &#39;将ak到bk列隐藏 raw.Columns(&quot;AK:BK&quot;).EntireColumn.Hidden = True &#39;将Columns换为rows即为对行操作清除Set raw = ThisWorkbook.Sheets(&quot;raw data&quot;) raw.Range(&quot;A2:MM&quot; &amp; raw.Rows.Count).ClearContents&#39;清除内容 raw.Range(&quot;A2:MM&quot; &amp; raw.Rows.Count).ClearFormats&#39;清除格式 raw.cells.clear&#39;全部清除选取文件夹可以让用户选取文件夹，并返回文件夹位置 Sub SelectFolder() Dim Path As String With Application.FileDialog(msoFileDialogFolderPicker) If .Show = -1 Then &#39;FileDialog 对象的 Show 方法显示对话框，并且返回 -1（如果按 OK）和 0（如果按 Cancel） Path = .SelectedItems(1) MsgBox &quot;您选择的文件夹是：&quot; &amp; Path, vbOKOnly + vbInformation &#39;获取到的Path长这个样子：&quot;D:\\VBA\\Report\\Format&quot;，Format就是我选中的文件夹的名字 End If End With End Sub 获取程序运行时间t = Timer &#39;中间加入想计时的代码块，这里我随意加上几句代码测试 Set raw = ThisWorkbook.Sheets(&quot;raw data&quot;) raw.Range(&quot;A2:MM&quot; &amp; raw.Rows.Count).ClearContents raw.Range(&quot;A2:MM&quot; &amp; raw.Rows.Count).ClearFormats MsgBox Timer - t 对指定列名进行操作注意match函数是大小写敏感的 &#39;忽略错误语句，如果Match找不到指定的值也不会报错,可以继续往下运行 On Error Resume Next c = Application.Match(&quot;Date&quot;, Rows(1), 0) &#39;在第一行查找Date列 If c &lt;&gt; &quot;&quot; then Columns(c).Format VBA中调用excel内置函数&#39;调用min和max函数 min_age = WorksheetFunction.Min(age.Columns(&quot;A&quot;)) enddate = Format(WorksheetFunction.Max(rawclean.Columns(&quot;AA&quot;)), &quot;yyyy/mm/dd&quot;) 调整数字格式&#39;一般格式 Columns(&quot;AA:AA&quot;).NumberFormat = &quot;General&quot; &#39;小数格式 Columns(&quot;AA:AA&quot;).NumberFormat = &quot;0.00&quot; &#39;日期格式 Columns(&quot;AA:AA&quot;).NumberFormat = &quot;m/d/yyyy&quot; &#39;百分比格式 Columns(&quot;AA:AA&quot;).NumberFormat = &quot;0.00%&quot; 关闭、开启系统提醒，刷新等设置一般VBA中常用的关闭提示如下，其他的提示设置等暂不赘述 Application.ScreenUpdating = False &#39;关闭屏幕更新 Application.DisplayAlerts = False &#39;关闭弹窗警告 Application.AskToUpdateLinks = False &#39;关闭程序询问更新链接提示 &#39;设置为true即可打开 Application.ScreenUpdating = True Application.DisplayAlerts = True Application.AskToUpdateLinks = True 选择多个不连续的区域&#39;两个或多个引用之间插入逗号，可使用 Range 属性引用多个区域 Worksheets(&quot;Sheet1&quot;).Range(&quot;C5:D9,G9:H16,B14:D18&quot;).ClearContents &#39;使用 Union 方法将多个区域合并为一个 Range Sub MultipleRange() Dim r1, r2, myMultipleRange As Range Set r1 = Sheets(&quot;Sheet1&quot;).Range(&quot;A1:B2&quot;) Set r2 = Sheets(&quot;Sheet1&quot;).Range(&quot;C3:D4&quot;) Set myMultipleRange = Union(r1, r2) myMultipleRange.Font.Bold = True End Sub 使用数组+字典方法实现Vlookup功能 Sub Vlookup_byarray() &#39;Arr为填写vlookup结果的区域 Arr = thisworkbook.sheets(&quot;test&quot;).Range(&quot;a1&quot;).CurrentRegion Set d = CreateObject(&quot;Scripting.Dictionary&quot;) &#39;d是字典,创建字典 arr1 = Sheets(&quot;raw&quot;).Range(&quot;a1&quot;).CurrentRegion &#39;ARR1就是要v的数据,即原始数据 For i = 2 To UBound(arr1) &#39;对于从Arr1里的所有数据 d(arr1(i, 1)) = arr1(i, 2) &#39;给字典赋值，键在数组第一列，值在数组第2列 Next For i = 2 To UBound(Arr) &#39;遍历Arr的所有数据 &#39;如果结果区域中第三列中的值在字典中存在，就在数组第10列返回其对应的值 If d.exists(Arr(i, 3)) Then Arr(i, 10) = d(Arr(i, 3)) Else Arr(i, 10) = &quot;没有该值，请检查&quot; End If Next d.RemoveAll &#39;清空字典 End Sub 同时替换多组值Sub ReplaceMulValues() Dim myRange As Range, myList As Range lastrow = ThisWorkbook.Sheets(&quot;plan&quot;).Cells(Rows.Count, 1).End(3).Row &#39;myRange为原始值区域 &#39;myList 为有替换前值和替换后值的列表区域 Set myRange = ThisWorkbook.Sheets(&quot;plan&quot;).Range(&quot;A6:A&quot; &amp; lastrow) Set myList = ThisWorkbook.Sheets(&quot;replacelist&quot;).Range(&quot;F2:G32&quot;) For Each cel In myList.Columns(1).Cells myRange.Replace What:=cel.value, Replacement:=cel.Offset(0, 1).value Next End Sub 使用数组实现复制粘贴为值的效果Set spsheet = ThisWorkbook.Sheets(&quot;test&quot;) &#39;先对arr数组赋值 arr = spsheet.Range(&quot;A1:Z10&quot;) &#39;再讲数组里的值赋值到结果区域。UBound(arr)为数组的行数，26是数组的列数 spsheet.[a9].Resize(UBound(arr), 26) = arr 新建一份excel文件 Sub new_file_result() &#39;创建一个新的excel文件并保存 Set excelApp = CreateObject(&quot;Excel.Application&quot;) &#39;新建模板文件 Set excelWB = excelApp.Workbooks.Add excelApp.DisplayAlerts = False savePath = ActiveWorkbook.path &amp; &quot;\\测试表.xlsx&quot; excelWB.SaveAs savePath excelApp.Quit End Sub 使用 Workbooks.Add 可以快速新建文件","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Excel & VBA","slug":"Excel-VBA","permalink":"http://smilecoc.vip/tags/Excel-VBA/"}],"author":"smilecoc"},{"title":"Python数据分析实战之营销组合模型","slug":"MMM","date":"2020-05-31T11:21:08.000Z","updated":"2020-06-20T04:45:38.188Z","comments":true,"path":"2020/05/31/MMM/","link":"","permalink":"http://smilecoc.vip/2020/05/31/MMM/","excerpt":"","text":"营销组合模型概述Marketing Mix Modeling （MMM）营销组合模型是一套统计分析技术，用来测量和预测不同营销行为对销售及ROI的影响。它被用来测量整体的marketing effectiveness并用来在不同的营销渠道中决定最优的预算分配 Marketing Mix中的“Mix”一词最早指的是Mix of 4Ps（Product，Price，Place &amp; Promotion）。早期MMM分析的目的就是为了理解并找到这4P的最优组合，同时测量并预测不同的营销活动对销售的不同影响。 时至今日，MMM中包含的变量更加广泛，一个Marketing Mix Model可以由以下这些类型的数据组成： Target Audience data （目标用户数据） Product data （产品数据，包括产品价格、产品特征） Competitive data（竞品数据） Industry data（行业数据） Economic data（经济数据） Marketing data（营销数据） Conversion data（转化数据如sales，profit，ROI） 营销组合模型实战1.首先导入数据与所需要的库import pandas as pd import numpy as np import matplotlib.patches as mpatches import matplotlib.pyplot as plt data = pd.read_excel(&#39;MMM.xlsx&#39;) 2.EDA(探索性数据分析)首先进行探索性数据分析，先大致的看一下各列数据 print (data.describe()) &gt;&gt;&gt; Brand ID Year Absolut Aristocrat Barton \\ count 263.000000 263.000000 263.000000 263.000000 263.000000 mean 12.596958 2001.695817 0.049430 0.049430 0.049430 std 7.654584 3.639093 0.217177 0.217177 0.217177 min 1.000000 1995.000000 0.000000 0.000000 0.000000 25% 6.000000 1999.000000 0.000000 0.000000 0.000000 50% 12.000000 2002.000000 0.000000 0.000000 0.000000 75% 18.000000 2005.000000 0.000000 0.000000 0.000000 max 31.000000 2007.000000 1.000000 1.000000 1.000000 Belvedere Burnett Chopin Crystal Palac Finlandia ... \\ count 263.000000 263.000000 263.000000 263.000000 263.000000 ... mean 0.026616 0.041825 0.026616 0.049430 0.049430 ... std 0.161265 0.200571 0.161265 0.217177 0.217177 ... min 0.000000 0.000000 0.000000 0.000000 0.000000 ... 25% 0.000000 0.000000 0.000000 0.000000 0.000000 ... 50% 0.000000 0.000000 0.000000 0.000000 0.000000 ... 75% 0.000000 0.000000 0.000000 0.000000 0.000000 ... max 1.000000 1.000000 1.000000 1.000000 1.000000 ... LagTotalMinusSales TierSales OutsideTierSales LagTierSales \\ count 263.000000 263.000000 263.000000 263.000000 mean 62673.935361 9547.235741 53106.615970 9215.528517 std 1548.346560 2917.310122 2259.775837 2946.563257 min 55687.000000 846.000000 48358.000000 697.000000 25% 62459.000000 8151.500000 51863.000000 7493.000000 50% 63204.000000 10605.000000 52335.000000 10400.000000 75% 63616.000000 11209.000000 54570.000000 11127.500000 max 64131.000000 15790.000000 59760.000000 14299.000000 LagOutsideTierSales Firstintro Marketshare LagMktshare YearID \\ count 263.000000 263.000000 263.000000 263.000000 263.000000 mean 53458.406844 0.015209 0.046972 0.047470 9.695817 std 2327.430916 0.122617 0.053831 0.054685 3.639093 min 49806.000000 0.000000 0.001468 0.000971 3.000000 25% 51947.000000 0.000000 0.014762 0.014655 7.000000 50% 52419.000000 0.000000 0.029463 0.029181 10.000000 75% 55392.000000 0.000000 0.053087 0.053633 13.000000 max 59868.000000 1.000000 0.270477 0.270477 15.000000 total ad count 263.000000 mean 7386.359312 std 14280.852135 min 6.000000 25% 6.000000 50% 6.000000 75% 9691.400000 max 70489.200000 可以看出数据总共有263行，同时查看有没有缺失数据的存在。 #查看是否有空值 data.isnull().any() ... diff False IfDom False DollarSales False PriceRerUnit False LagPrice True LnPrice False LnLPrice True Mag False News False ... 查看列，数据的数据字典已经放在MMM数据文件中，可以对照着看一下各列的含义注意：数据已经清洗过，所以缺失值较少，同时由于需要的字段中的数字数量级相差较大，所以对其进行取对数处理 print (data.columns) &gt;&gt;&gt; [8 rows x 66 columns] Index([&#39;BrandName&#39;, &#39;Brand ID&#39;, &#39;Year&#39;, &#39;Absolut&#39;, &#39;Aristocrat&#39;, &#39;Barton&#39;, &#39;Belvedere&#39;, &#39;Burnett&#39;, &#39;Chopin&#39;, &#39;Crystal Palac&#39;, &#39;Finlandia&#39;, &#39;Fleischmann&#39;s&#39;, &#39;Fris&#39;, &#39;Gilbey&#39;s&#39;, &#39;Gordon&#39;s&#39;, &#39;Grey Goose&#39;, &#39;Kamchatka&#39;, &#39;Ketel One&#39;, &#39;Level&#39;, &#39;McCormick&#39;, &#39;Polar Ice&#39;, &#39;Popov&#39;, &#39;Pravda&#39;, &#39;Seagram&#39;s&#39;, &#39;Skol&#39;, &#39;Sky&#39;, &#39;Smirnoff&#39;, &#39;Stolicnaya&#39;, &#39;Tanqueray&#39;, &#39;Three Olives&#39;, &#39;TotalSales&#39;, &#39;LagTotalSales&#39;, &#39;2LagTotalSales&#39;, &#39;LnSales&#39;, &#39;LnLSales&#39;, &#39;Ln2Lsales&#39;, &#39;LnDiff&#39;, &#39;diff&#39;, &#39;IfDom&#39;, &#39;DollarSales&#39;, &#39;PriceRerUnit&#39;, &#39;LagPrice&#39;, &#39;LnPrice&#39;, &#39;LnLPrice&#39;, &#39;Mag&#39;, &#39;News&#39;, &#39;Outdoor&#39;, &#39;Broad&#39;, &#39;Print&#39;, &#39;LnMag&#39;, &#39;LnNews&#39;, &#39;LnOut&#39;, &#39;LnBroad&#39;, &#39;LnPrint&#39;, &#39;Tier1&#39;, &#39;Tier2&#39;, &#39;TotalMinusSales&#39;, &#39;LagTotalMinusSales&#39;, &#39;TierSales&#39;, &#39;OutsideTierSales&#39;, &#39;LagTierSales&#39;, &#39;LagOutsideTierSales&#39;, &#39;Firstintro&#39;, &#39;Marketshare&#39;, &#39;LagMktshare&#39;, &#39;YearID&#39;, &#39;total ad&#39;], dtype=&#39;object&#39;)接下来再看数据中一共有多少个品牌： print (data[&#39;BrandName&#39;].unique()) print (&#39;\\n&#39;) print (&#39;Total Number of brands&#39;,len(data[&#39;BrandName&#39;].unique())) &gt;&gt;&gt; [&#39;Absolut&#39; &#39;Aristocrat&#39; &#39;Barton&#39; &#39;Belvedere&#39; &#39;Burnett&#39; &#39;Chopin&#39; &#39;Crystal Palac&#39; &#39;Finlandia&#39; &quot;Fleischmann&#39;s&quot; &#39;Fris&#39; &quot;Gilbey&#39;s&quot; &quot;Gordon&#39;s&quot; &#39;Grey Goose&#39; &#39;Kamchatka&#39; &#39;Ketel One&#39; &#39;Level&#39; &#39;McCormick&#39; &#39;Polar Ice&#39; &#39;Popov&#39; &#39;Pravda&#39; &quot;Seagram&#39;s&quot; &#39;Skol&#39; &#39;Sky&#39; &#39;Smirnoff&#39; &#39;Stolicnaya&#39; &#39;Tanqueray&#39; &#39;Three Olives&#39;] Total Number of brands 27可以看到该数据集包括总共27个伏特加制造公司品牌。对于MMM，让我们选择一个品牌并分析价格对销售的影响。例如，让我们选择’Absolut’作为我们的分析品牌。 Absolut = data[data[&#39;BrandName&#39;] == &#39;Absolut&#39;]] Pr_Absolut = Absolut[[&#39;LnSales&#39;,&#39;LnPrice&#39;]]之后画出Absolut的价格与销售之间的关系 plt.scatter(Pr_Absolut[&#39;LnPrice&#39;],Pr_Absolut[&#39;LnSales&#39;]) plt.xlabel(&#39;Log of Price&#39;) plt.ylabel(&#39;Log of Sales&#39;) plt.show()matplotlib.pyplot.scatte函数的语法为： matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, , data=None, *kwargs) 参数的解释：x，y：表示的是大小为(n,)的数组，也就是我们即将绘制散点图的数据点 s:是一个实数或者是一个数组大小为(n,)，这个是一个可选的参数。 c:表示的是颜色，也是一个可选项。默认是蓝色’b’,表示的是标记的颜色，或者可以是一个表示颜色的字符，或者是一个长度为n的表示颜色的序列等等，感觉还没用到过现在不解释了。但是c不可以是一个单独的RGB数字，也不可以是一个RGBA的序列。可以是他们的2维数组（只有一行）。 marker:表示的是标记的样式，默认的是’o’。 cmap:Colormap实体或者是一个colormap的名字，cmap仅仅当c是一个浮点数数组的时候才使用。如果没有申明就是image.cmap norm:Normalize实体来将数据亮度转化到0-1之间，也是只有c是一个浮点数的数组的时候才使用。如果没有申明，就是默认为colors.Normalize。 vmin,vmax:实数，当norm存在的时候忽略。用来进行亮度数据的归一化。oalpha：实数，0-1之间。 linewidths:也就是标记点的长度 得到的散点图如下所示：从生成的散点图中我们可以知道随着价格的增长销量增加。 import statsmodels.formula.api as sm result = sm.ols(formula = &#39;LnSales ~ LnPrice&#39;,data = Pr_Absolut).fit() result.summary()Statsmodels 是 Python 中一个强大的统计分析包，包含了回归分析、时间序列分析、假设检验等等的功能,当我们需要使用回归时，只需要import statsmodels.formula.api as sm即可（也可以import statsmodels.api as sm，两者的用法会有一些差别，但是具有相同的功能）。 使用sm.ols(formula = ‘LnSales ~ LnPrice’,data = Pr_Absolut).fit()即可获取拟合结果 #获取计算出的回归系数 print(result.params) #打印出全部摘要 print(result.summary()) 得到的回归系数与概要： Intercept 2.836674LnPrice 1.130972从上述的描述中可以得到R方（R-squared）的值为0.688，即此函数接近69％的数据点。价格系数表明，每增加单位价格，销售额便增加1.13倍。同时P&gt;|t|的值为0.表示两者之间有非常显著的关系 我们还可以将拟合结果画出来。 #先调用拟合结果的 fittedvalues 得到拟合的 y 值。 y_fitted = result.fittedvalues #然后使用 matplotlib.pyploft 画图。首先设定图轴，图片大小为 8×6。 fig, ax = plt.subplots(figsize=(8,6)) #画出原数据，图像为圆点，默认颜色为蓝。 ax.plot(x, y, &#39;o&#39;, label=&#39;data&#39;) #画出拟合数据，图像为红色带点间断线。 ax.plot(x, y_fitted, &#39;r--.&#39;,label=&#39;OLS&#39;) #放置注解。 ax.legend(loc=&#39;best&#39;) 得到的拟合曲线与散点图的关系如图 接下来我们向回归中添加更多变量，看看R方会发生什么。 首先尝试使用广告和价格列 Ad_Absolut = Absolut[[&#39;LnSales&#39;,&#39;LnMag&#39;,&#39;LnNews&#39;,&#39;LnOut&#39;,&#39;LnBroad&#39;,&#39;LnPrint&#39;,&#39;LnPrice&#39;]] result_ad = sm.ols(&#39;LnSales ~ LnMag + LnNews + LnOut + LnBroad + LnPrint + LnPrice&#39;,data=Ad_Absolut).fit() result_ad.summary()得到如下结果 调整R方值（Adj. R-squared）显示该模型能够解释87％的数据点。但是，此处某些变量的p值很高，这可能是由于相互作用效应和其他一些因素导致的。 注:多元回归实际应用中，判定系数R平方有个最大的问题：增加自变量的个数时，判定系数就会增加，即随着自变量的增多，R平方会越来越大，会显得回归模型精度很高，有较好的拟合效果。而实际上可能并非如此，有些自变量与因变量（即预测）完全不相关，增加这些自变量，并不会提升拟合水平和预测精度。调整R方同时考虑了样本量（n）和回归中自变量的个数（k）的影响，这使得调整R方永远小于R方，而且调整R方的值不会由于回归中自变量个数的增加而越来越接近1。因此，在多元回归分析中，通常用调整的多重判定系数来评价拟合效果 同时我们也可以通过其他的单因素的回归分析来判断各个媒体对实际销售的影响 通过回归系数，我们知道某一个自变量对自变量的影响的程度有多大 同时，我们还可以看一下各个因素与销售量之间相关性 print(Ad_Absolut.corr())得到相关系数如图：源码和实验数据文件地址：https://github.com/smilecoc/Data_analysis/tree/master/MMM","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Python数据分析","slug":"Python数据分析","permalink":"http://smilecoc.vip/tags/Python数据分析/"}],"author":"smilecoc"},{"title":"Python骚操作之使用python做个视频","slug":"Python视频相关操作","date":"2020-05-20T12:13:14.000Z","updated":"2020-06-20T04:46:08.988Z","comments":true,"path":"2020/05/20/Python视频相关操作/","link":"","permalink":"http://smilecoc.vip/2020/05/20/Python视频相关操作/","excerpt":"","text":"在这篇文章中，我们将使用Python下载视频，并将普通的视频转化为的代码版本的视频，效果如下： 首先我们需要获取网页上的视频。一般情况下通过APP或者网页上的视频下载的问题有：1.没有提供下载按钮导致无法下载2.下载后的格式一般为.flv格式，或者是有自己的格式无法解析（例如B站） 针对第一个问题,我们的解决办法就是Python中的you_get库.You-Get 只需要一行代码就可以便利的下载网络上的媒体信息 you_get下载视频you_get主页:https://github.com/soimort/you-get中文说明文档:https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E 首先依旧是需要安装you-get库,同时还需要安装FFmpeg,这个工具是you-get库的必要依赖，同时也会在其他的地方用到。本篇文章提供的FFmpeg地址为解压免安装版本，下载后解压并记一下文件路径。其他 安装完成后如果想下载某个网页的视频,,只需要一句简单的 you-get+网址即可下载视频. $ you-get http://www.fsf.org/blogs/rms/20140407-geneva-tedx-talk-free-software-free-society Site: fsf.org Title: TEDxGE2014_Stallman05_LQ Type: WebM video (video/webm) Size: 27.12 MiB (28435804 Bytes) Downloading TEDxGE2014_Stallman05_LQ.webm ... 100.0% ( 27.1/27.1 MB) ├████████████████████████████████████████┤[1/1] 12 MB/s需要注意一点,上述例子you_get的基本命令是在cmd中输入的命令行,如果我们使用IDE时需要使用os.system()方法来执行cmd命令 import os os.system(&#39;you-get http://www.fsf.org/blogs/rms/20140407-geneva-tedx-talk-free-software-free-society&#39;) 在一下的you_get示例中，所有的代码均为cmd的代码，所以使用IDE的同学记得要在代码前加入os.system()函数以保证正确运行。 在下载前可以使用 –info/-i 以查看所有可用画质与格式： $ you-get -i &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39; site: YouTube title: Me at the zoo streams: # Available quality and codecs [ DEFAULT ] _________________________________ - itag: 43 container: webm quality: medium size: 0.5 MiB (564215 bytes) # download-with: you-get --itag=43 [URL] - itag: 18 container: mp4 quality: medium # download-with: you-get --itag=18 [URL] - itag: 5 container: flv quality: small # download-with: you-get --itag=5 [URL] - itag: 36 container: 3gp quality: small # download-with: you-get --itag=36 [URL] - itag: 17 container: 3gp quality: small # download-with: you-get --itag=17 [URL]标有DEFAULT 为默认画质。使用上述下载语句即可开始下载默认画质的视频 如果希望下载其他格式或画质的视频，使用提示中出现的 # download-with: 选项即可。例如我想下载上述示例中的MP4格式的视屏： $ you-get --itag=18 &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;当下载视频遇到问题时： 一是排除网络问题； 二是确保you-get更新到最新版本； 三是检查目标视频是否已经确认无法爬取。 四–debug参数进行调试 同时可以使用–output-dir/-o 设定路径, –output-filename/-O 设定输出文件名: $ you-get -o ~/Videos -O zoo.webm &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;这样从网页上下载视频的问题就解决了！ 视频格式转化第二个问题就是从网页上下载视频的视频很只有flv格式，不利于预览和处理。因此需要转化视频格式，比如转化成MP4格式。但是一般在线频转化要么有视频大小的限制，要么需要下载app或者会员。这时候就要用到上面我们下载的FFmpeg处理视频 FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。使用FFmpeg 命令行处理视频，比桌面视频处理软件更简洁高效。 例如我们想把所有的flv文件转化为mp4文件：（本部分涉及cmd命令与FFmpeg 命令行，如有疑问可以先搜一下Windows cmd命令的用法和FFmpeg 命令行的用法） 1.解压后打开bin，把三个可执行文件复制到C:\\Windows\\system32 2.打开CMD，cd 到指定文件夹 3.执行cmd命令：for %i in (*.flv) do ffmpeg -i “%i” -c copy “%~ni.mp4” 之后就可以发现所有的flv格式视频全部转化为了MP4格式。 转化代码版视频之后就可以将普通的视频转化为代码版视频了。这里使用的代码原作者文章：https://www.cnblogs.com/TurboWay/p/9748535.html 使用方法：一、环境准备 1.需要安装opencv，直接安装 pip install opencv-python 2.需要安装ffmpeg （上述步骤中已下载解压的可跳过），直接解压免安装，下载传送门； 3.将 ffmpeg.exe 的路径复制，替换代码开头的 ffmpeg = r’G:\\ffmpeg\\bin\\ffmpeg.exe’ 二、如何使用： 1.替换主函数里的vedio视频地址 2.运行程序即可 注意对存储空间的要求较高，请保证有足够的存储空间 代码如下： # -*- coding:utf-8 -*- # coding:utf-8 import os, cv2, subprocess, shutil from cv2 import VideoWriter, VideoWriter_fourcc, imread, resize from PIL import Image, ImageFont, ImageDraw ffmpeg = r&#39;D:\\ffmpeg\\bin\\ffmpeg.exe&#39; code_color = (169,169,169) # 颜色RGB 默认灰色 ，&#39;&#39; 则彩色 # 像素对应ascii码 #ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:oa+&gt;!:+. &quot;) #ascii_char = [&#39;.&#39;,&#39;,&#39;,&#39;:&#39;,&#39;;&#39;,&#39;+&#39;,&#39;*&#39;,&#39;?&#39;,&#39;%&#39;,&#39;S&#39;,&#39;#&#39;,&#39;@&#39;][::-1] #ascii_char = list(&quot;MNHQ$OC67+&gt;!:-. &quot;) ascii_char = list(&quot;MNHQ$OC67)oa+&gt;!:+. &quot;) # 将像素转换为ascii码 def get_char(r, g, b, alpha=256): if alpha == 0: return &#39;&#39; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1) / length return ascii_char[int(gray / unit)] # 将txt转换为图片 def txt2image(file_name): im = Image.open(file_name).convert(&#39;RGB&#39;) # gif拆分后的图像，需要转换，否则报错，由于gif分割后保存的是索引颜色 raw_width = im.width raw_height = im.height width = int(raw_width / 6) height = int(raw_height / 15) im = im.resize((width, height), Image.NEAREST) txt = &quot;&quot; colors = [] for i in range(height): for j in range(width): pixel = im.getpixel((j, i)) colors.append((pixel[0], pixel[1], pixel[2])) if (len(pixel) == 4): txt += get_char(pixel[0], pixel[1], pixel[2], pixel[3]) else: txt += get_char(pixel[0], pixel[1], pixel[2]) txt += &#39;\\n&#39; colors.append((255, 255, 255)) im_txt = Image.new(&quot;RGB&quot;, (raw_width, raw_height), (255, 255, 255)) dr = ImageDraw.Draw(im_txt) # font = ImageFont.truetype(os.path.join(&quot;fonts&quot;,&quot;汉仪楷体简.ttf&quot;),18) font = ImageFont.load_default().font x = y = 0 # 获取字体的宽高 font_w, font_h = font.getsize(txt[1]) font_h *= 1.37 # 调整后更佳 # ImageDraw为每个ascii码进行上色 for i in range(len(txt)): if (txt[i] == &#39;\\n&#39;): x += font_h y = -font_w # self, xy, text, fill = None, font = None, anchor = None, # *args, ** kwargs if code_color: dr.text((y, x), txt[i], fill=code_color) # fill=colors[i]彩色 else: dr.text((y, x), txt[i], fill=colors[i]) # fill=colors[i]彩色 # dr.text((y, x), txt[i], font=font, fill=colors[i]) y += font_w name = file_name # print(name + &#39; changed&#39;) im_txt.save(name) # 将视频拆分成图片 def video2txt_jpg(file_name): vc = cv2.VideoCapture(file_name) c = 1 if vc.isOpened(): r, frame = vc.read() if not os.path.exists(&#39;Cache&#39;): os.mkdir(&#39;Cache&#39;) os.chdir(&#39;Cache&#39;) else: r = False while r: cv2.imwrite(str(c) + &#39;.jpg&#39;, frame) txt2image(str(c) + &#39;.jpg&#39;) # 同时转换为ascii图 r, frame = vc.read() c += 1 os.chdir(&#39;..&#39;) return vc # 将图片合成视频 def jpg2video(outfile_name, fps): fourcc = VideoWriter_fourcc(*&quot;MJPG&quot;) images = os.listdir(&#39;Cache&#39;) im = Image.open(&#39;Cache/&#39; + images[0]) vw = cv2.VideoWriter(outfile_name, fourcc, fps, im.size) os.chdir(&#39;Cache&#39;) for image in range(len(images)): # Image.open(str(image)+&#39;.jpg&#39;).convert(&quot;RGB&quot;).save(str(image)+&#39;.jpg&#39;) frame = cv2.imread(str(image + 1) + &#39;.jpg&#39;) vw.write(frame) # print(str(image + 1) + &#39;.jpg&#39; + &#39; finished&#39;) os.chdir(&#39;..&#39;) vw.release() # 调用ffmpeg获取mp3音频文件 def video2mp3(file_name, outfile_name): cmdstr = &quot; -i {0} -f mp3 {1} -y&quot;.format(file_name, outfile_name) cmd(cmdstr) # 合成音频和视频文件 def video_add_mp3(file_name, mp3_file,outfile_name): cmdstr = &quot; -i {0} -i {1} -strict -2 -f mp4 {2} -y&quot;.format(file_name, mp3_file, outfile_name) cmd(cmdstr) # 视频截取 def vediocut(file_name, outfile_name, start, end): cmdstr = &quot; -i {0} -vcodec copy -acodec copy -ss {1} -to {2} {3} -y&quot;.format(file_name,start,end,outfile_name) cmd(cmdstr) # 执行脚本命令 def cmd(cmdstr): cmdstr = ffmpeg + cmdstr response = subprocess.call(cmdstr, shell=True, creationflags=0x08000000) if response == 1: print(&quot;ffmpeg脚本执行失败,请尝试手动执行:{0}&quot;.format(cmdstr)) # 主函数 def main(vedio, save=False, iscut=False, start=&#39;00:00:00&#39;, end=&#39;00:00:14&#39;): &quot;&quot;&quot; :param vedio: 原视频文件地址 :param save: 是否保存临时文件 默认不保存 :param iscut: 是否先对原视频做截取处理 默认不截取 :param start: 视频截取开始时间点 仅当iscut=True时有效 :param end: 视频截取结束时间点 仅当iscut=True时有效 :return: 输出目标视频文件 vedio.split(&#39;.&#39;)[0] + &#39;-code.mp4&#39; &quot;&quot;&quot; file_cut = vedio.split(&#39;.&#39;)[0] + &#39;_cut.mp4&#39; file_mp3 = vedio.split(&#39;.&#39;)[0] + &#39;.mp3&#39; file_temp_avi = vedio.split(&#39;.&#39;)[0] + &#39;_temp.avi&#39; outfile_name = vedio.split(&#39;.&#39;)[0] + &#39;-code.mp4&#39; print(&quot;开始生成...&quot;) if iscut: print(&quot;正在截取视频...&quot;) vediocut(vedio, file_cut, start, end) vedio = file_cut print(&quot;正在转换代码图片...&quot;) vc = video2txt_jpg(vedio) # 视频转图片，图片转代码图片 FPS = vc.get(cv2.CAP_PROP_FPS) # 获取帧率 vc.release() print(&quot;正在分离音频...&quot;) video2mp3(vedio, file_mp3) # 从原视频分离出 音频mp3 print(&quot;正在转换代码视频...&quot;) jpg2video(file_temp_avi, FPS) #代码图片转视频 print(&quot;正在合成目标视频...&quot;) video_add_mp3(file_temp_avi, file_mp3, outfile_name) # 将音频合成到代码视频 if (not save): # 移除临时文件 print(&quot;正在移除临时文件...&quot;) shutil.rmtree(&quot;Cache&quot;) for file in [file_cut, file_mp3, file_temp_avi]: if os.path.exists(file): os.remove(file) print(&quot;生成成功：{0}&quot;.format(outfile_name)) if __name__ == &#39;__main__&#39;: vedio = r&quot;test.mp4&quot; main(vedio, save=False, iscut=False, start=&#39;00:00:00&#39;, end=&#39;00:00:14&#39;) 这样就可以将一个视频转化为代码版的视频了！","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"python其他","slug":"python其他","permalink":"http://smilecoc.vip/tags/python其他/"}],"author":"smilecoc"},{"title":"实用网站资源整理汇总","slug":"实用网站汇总","date":"2020-04-12T14:06:14.000Z","updated":"2020-07-20T15:27:37.939Z","comments":true,"path":"2020/04/12/实用网站汇总/","link":"","permalink":"http://smilecoc.vip/2020/04/12/实用网站汇总/","excerpt":"","text":"简单快速制作海报的网站,还可以设计PPT等其他内容：https://www.canva.cn/ 线上 PS 工具,功能几乎和 PS 软件一样，网页打开，方便快捷,而且免费。https://www.photopea.com/ 十分钟邮箱，可以生成一个短时间存在的邮箱地址，并且可在对应时间段内接收邮件https://10minutemail.net/m/?lang=zh 在线绘制流程图，支持团队协作绘制https://www.processon.com/ 免费壁纸下载网站https://wallhaven.cc/ 万能命令,浏览任意网页时，在网址前面输入这个万能命令 wn.run/ 就会展示出用于该网页的各种附加在线工具https://wanneng.run/cn/ 一个很有趣的人格测试网站https://www.16personalities.com/ch 一个在线绘图网站http://weavesilk.com/ 免费高清图片素材下载https://pixabay.com/ 字符串转码工具https://tool.chinaz.com/tools/unicode.aspx 一个在线工时任务管理网站https://cs.cornerstone365.cn/ 介绍旅游线路的网站，只适用于手机端http://www.doyouhike.net/mobile 狗屁不通文章生成器，只求字数不求质量https://suulnnka.github.io/BullshitGenerator/ 沙雕网站，可以生成祖安话，彩虹屁，文案。。。。https://shadiao.app/ 正则表达式速查表，程序员宝典https://www.jb51.net/shouce/jquery1.82/regexp.html 在线转换图片，文档等https://www.aconvert.com/cn/ PDF合并，可以将多个pdf合并后直接打印，不用一张一张打印啦https://www.ilovepdf.com/zh-cn/merge_pdf Vitu.ai,一个涵盖ai学习资源和实践应用的网站,还支持在线代码与数据集的使用https://vitu.ai/ The GDELT Project,一个监测全球媒体的情感倾向的网站，可以看到全球各国的舆论导向并获取数据https://www.gdeltproject.org/ 鸠摩搜书,可以搜到很多的电子书资源https://www.jiumodiary.com/ pdf在线免费转换https://easypdf.com/cn 下载记录查询,可以看到其他ip下载的资源是什么https://iknowwhatyoudownload.com/ 两个好用的在线文本差异比较工具https://text-compare.com/https://www.diffchecker.com/diff 卡巴斯基网络威胁实时地图https://www.cybermap.kaspersky.com/cn/ 小森平的免费下载音效https://taira-komori.jpn.org/freesoundcn.html 网易见外工作台https://jianwai.youdao.com/ greasyfork,油猴脚本下载网站https://greasyfork.org/zh-CN","categories":[{"name":"资源","slug":"资源","permalink":"http://smilecoc.vip/categories/资源/"}],"tags":[{"name":"其他资源","slug":"其他资源","permalink":"http://smilecoc.vip/tags/其他资源/"}],"author":"smilecoc"},{"title":"数据分析面试题整理汇总","slug":"SQL面试题整理汇总","date":"2020-04-05T02:24:33.000Z","updated":"2020-07-08T16:26:42.547Z","comments":true,"path":"2020/04/05/SQL面试题整理汇总/","link":"","permalink":"http://smilecoc.vip/2020/04/05/SQL面试题整理汇总/","excerpt":"","text":"第一题：活动运营数据分析表1——订单表orders，要用到的字段有（user_id‘用户编号’, order_pay‘订单金额’ , order_time‘下单时间’）。表2——活动报名表act_apply，要用到的字段有（act_id‘活动编号’, user_id‘报名用户’,act_time‘报名时间’）注意这里的表1和表2都还有其他的字段 需求： 统计每个活动对应所有用户在报名后产生的总订单金额，总订单数。（每个用户限报一个活动,题干默认用户报名后产生的订单均为参加活动的订单）。 统计每个活动从开始后到今天平均每天产生的订单数，活动开始时间定义为最早有用户报名的时间。（涉及到时间的数据类型均为：datetime）。 答案：1. select t2.act_id,sum(order_pay) as total_cost,count(order_time) as order_num from (select user_id，order_pay，order_time from orders) as t1 inner join (select act_id,user_id,act_time) as t2 on t1.user_id=t2.user_id where t1.order_time&gt;=t2.act_time group by t2.act_id 2. select t1.act_id,count(order_time)/dateiff(now(),t1.begin_time) as avg_ordercount from (select act_id,user_id,act_time,min(act_time) over (partition by act_id) as begin_time from act_apply) as t1 inner join (select user_id,order_time from orders) as t2 on t1.user_id=t2.user_id where t1.act_time between t1.begin_time and now() and t2.order_time &gt;= t1.act_time group by t1.act_id 第二题涉及到over函数的使用 第二题：用户行为分析表1——用户行为表tracking_log，大概字段有（user_id‘用户编号’,opr_id‘操作编号’,log_time‘操作时间’） 需求： 1、计算每天的访客数和他们的平均操作次数。 2、统计每天符合以下条件的用户数：A操作之后是B操作，AB操作必须相邻。 答案：1. select date(log_time),count(distinct user_id) as user_num,avg(num_ci) as avg_operqationcount from (select date(log_time),user_id,count(opr_id) as num_ci from tracking_log group by date(log_time),user_id) group by date(log_time) 2. select date(log_time),count(distinct user_id) as user_num from (select user_id,date(log_time),opr_id,lead(opr_id,1) over(partition by user_id order by lod_time) as opr_id_2 from tracking_log) where opr_id=&#39;A&#39; and opr_id_2=&#39;B&#39; group by date(log_time) 使用lead() over()实现 第三题：用户新增留存分析表1——用户登陆表user_log，大概字段有（user_id‘用户编号’，log_time‘登陆时间’） 要求： 每天新增用户数，以及他们第2天、30天的回访比例 如何定义新增用户：用户登陆表中最早的登陆时间所在的用户数为当天新增用户数； 第2天回访用户数：第一天登陆的用户中，第二天依旧登陆的用户；–次日留存率 第30天的回访用户数：第一天登陆用户中，第30天依旧登陆的用户； select date(t1.user_begin),count(distinct t1.user_id) as new_user,count(distinct t2.user_id) as twodays_retained_users,count(distinct t3.user_id) as thrityday_retained_users from (select user_id,min(log_time) as user_begin from user_log group by user_id) t1 left join (select user_id,log_time from user_log) t2 on t1.user_id=t2.user_id and date(t2.log_time)=date(t1.user_begin)+1 left join (select user_id,log_time from user_log) t3 on t1.user_id=t3.user_id and date(t3.log_time)=date(t1.user_begin)+29 group by date(t1.user_begin) 第四题：数学计算题已知A,B厂生产的产品的次品率分别是1%和2%，现在由A,B产品分别占60%、40%的样品中随机抽一件，若取到的是次品，求此次品是B厂生产的概率。 已知：P(A)=0.6,P(B)=0.4,P(次/A)=0.01,P(次/B)=0.02 求：P(B/次) 答案：P(B/次)=P(次/B)P(B)/(P(次/B)P(B)+P(次/A)P(A)) 贝叶斯公式的应用 第五题：AB test某网站优化了商品详情页，现在新旧两个版本同时运行，新版页面覆盖了10%的用户，旧版覆盖90%的用户。现在需要了解，新版页面是否能够提高商品详情页到支付页的转化率，并决定是否要覆盖旧版，你能为决策提供哪些信息，需要收集哪些指标，给出统计方法及过程。 解答： 使用A/B测试模型，分析两个版本在一段时间期限内，详情页面到支付页面的转化率变化，并计算转化率变化后引起的的GMV变化。 可选择的决策：①确定发布新版本；②调整分流比例继续测试；③优化迭代方案重新开发。 要统计的指标：期限内新、旧版本商品详情页到支付页转化率 ，支付金额。 要衡量的指标：转化率变化 t 在是可接受的置信区间内是否显著，同时参考收益提升率。 指标计算方法：转化率=从某详情页到支付页用户数/浏览该商品详情页用户数（取日平均和标准差） 支付金额=从某详情页到支付页到支付成功路径用户的本次支付金额（取日平均） 采用决策①的情况：本次页面改进在显著性水平内，证明了‘转化率提升的假设’。并且收益提升率达到预期水平。 采用决策②的情况：本次页面改进在显著性水平内，无法证明‘转化率提升的假设’。分析原因可能是新版本样本空间不足。 采用决策③的情况：本次页面改进在显著性水平内，证明了‘转化率提升的假设’。但是收益提升率没有达到预期水平。s","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"SQL面试44题","slug":"SQL面试44题","date":"2020-04-04T08:24:08.000Z","updated":"2020-07-08T16:26:50.283Z","comments":true,"path":"2020/04/04/SQL面试44题/","link":"","permalink":"http://smilecoc.vip/2020/04/04/SQL面试44题/","excerpt":"","text":"01 建表语句create table Student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10)); insert into Student values(&#39;01&#39; , &#39;赵雷&#39; , &#39;1990-01-01&#39; , &#39;男&#39;); insert into Student values(&#39;02&#39; , &#39;钱电&#39; , &#39;1990-12-21&#39; , &#39;男&#39;); insert into Student values(&#39;03&#39; , &#39;孙风&#39; , &#39;1990-05-20&#39; , &#39;男&#39;); insert into Student values(&#39;04&#39; , &#39;李云&#39; , &#39;1990-08-06&#39; , &#39;男&#39;); insert into Student values(&#39;05&#39; , &#39;周梅&#39; , &#39;1991-12-01&#39; , &#39;女&#39;); insert into Student values(&#39;06&#39; , &#39;吴兰&#39; , &#39;1992-03-01&#39; , &#39;女&#39;); insert into Student values(&#39;07&#39; , &#39;郑竹&#39; , &#39;1989-07-01&#39; , &#39;女&#39;); insert into Student values(&#39;08&#39; , &#39;王菊&#39; , &#39;1990-01-20&#39; , &#39;女&#39;); create table Course(cid varchar(10),cname varchar(10),tid varchar(10)); insert into Course values(&#39;01&#39; , &#39;语文&#39; , &#39;02&#39;); insert into Course values(&#39;02&#39; , &#39;数学&#39; , &#39;01&#39;); insert into Course values(&#39;03&#39; , &#39;英语&#39; , &#39;03&#39;); create table Teacher(tid varchar(10),tname varchar(10)); insert into Teacher values(&#39;01&#39; , &#39;张三&#39;); insert into Teacher values(&#39;02&#39; , &#39;李四&#39;); insert into Teacher values(&#39;03&#39; , &#39;王五&#39;); create table SC(sid varchar(10),cid varchar(10),score decimal(18,1)); insert into SC values(&#39;01&#39; , &#39;01&#39; , 80); insert into SC values(&#39;01&#39; , &#39;02&#39; , 90); insert into SC values(&#39;01&#39; , &#39;03&#39; , 99); insert into SC values(&#39;02&#39; , &#39;01&#39; , 70); insert into SC values(&#39;02&#39; , &#39;02&#39; , 60); insert into SC values(&#39;02&#39; , &#39;03&#39; , 80); insert into SC values(&#39;03&#39; , &#39;01&#39; , 80); insert into SC values(&#39;03&#39; , &#39;02&#39; , 80); insert into SC values(&#39;03&#39; , &#39;03&#39; , 80); insert into SC values(&#39;04&#39; , &#39;01&#39; , 50); insert into SC values(&#39;04&#39; , &#39;02&#39; , 30); insert into SC values(&#39;04&#39; , &#39;03&#39; , 20); insert into SC values(&#39;05&#39; , &#39;01&#39; , 76); insert into SC values(&#39;05&#39; , &#39;02&#39; , 87); insert into SC values(&#39;06&#39; , &#39;01&#39; , 31); insert into SC values(&#39;06&#39; , &#39;03&#39; , 34); insert into SC values(&#39;07&#39; , &#39;02&#39; , 89); insert into SC values(&#39;07&#39; , &#39;03&#39; , 98); 02 表结构预览--学生表 Student(SId,Sname,Sage,Ssex) --SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别 --课程表 Course(CId,Cname,TId) --CId 课程编号,Cname 课程名称,TId 教师编号 --教师表 Teacher(TId,Tname) --TId 教师编号,Tname 教师姓名 --成绩表 SC(SId,CId,score) --SId 学生编号,CId 课程编号,score 分数 题解1. 查询“01”课程比“02”课程成绩高的所有学生的学号；select distinct t1.sid as sidfrom (select * from sc where cid=&#39;01&#39;)t1 left join (select * from sc where cid=&#39;02&#39;)t2 on t1.sid=t2.sid where t1.score&gt;t2.score 2. 查询平均成绩大于60分的同学的学号和平均成绩；select sid ,avg(score) from sc group by sid having avg(score)&gt;60 3. 查询所有同学的学号、姓名、选课数、总成绩select student.sid as sid ,sname ,count(distinct cid) course_cnt ,sum(score) as total_score from student left join sc on student.sid=sc.sid group by sid,sname 4. 查询姓“李”的老师的个数；select count(distinct tid) as teacher_cnt from teacher where tname like &#39;李%&#39; 5. 查询没学过“张三”老师课的同学的学号、姓名；select sid,sname from student where sid not in ( select sc.sid from teacher left join course on teacher.tid=course.tid left join sc on course.cid=sc.cid where teacher.tname=&#39;张三&#39; ) 6. 查询学过“01”并且也学过编号“02”课程的同学的学号、姓名；select t.sid as sid ,sname from ( select sid ,count(if(cid=&#39;01&#39;,score,null)) as count1 ,count(if(cid=&#39;02&#39;,score,null)) as count2 from sc group by sid having count(if(cid=&#39;01&#39;,score,null))&gt;0 and count(if(cid=&#39;02&#39;,score,null))&gt;0 )t left join student on t.sid=student.sid 7. 查询学过“张三”老师所教的课的同学的学号、姓名；select student.sid ,sname from ( select distinct cid from course left join teacher on course.tid=teacher.tid where teacher.tname=&#39;张三&#39; )course left join sc on course.cid=sc.cid left join student on sc.sid=student.sid group by student.sid,sname 8. 查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；select t1.sid,sname from ( select distinct t1.sid as sid from (select * from sc where cid=&#39;01&#39;)t1 left join (select * from sc where cid=&#39;02&#39;)t2 on t1.sid=t2.sid where t1.score&gt;t2.score )t1 left join student on t1.sid=student.sid 9. 查询所有课程成绩小于60分的同学的学号、姓名；select t1.sid,sname from ( select sid,max(score) from sc group by sid having max(score&lt;60) )t1 left join student on t1.sid=student.sid 10. 查询没有学全所有课的同学的学号、姓名；select t1.sid,sname from ( select count(cid),sid from sc group by sid having count(cid) &lt; (select count(distinct cid) from course) )t1 left join student on t1.sid=student.sid 11. 查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；select distinct sc.sid from ( select cid from sc where sid=&#39;01&#39; )t1 left join sc on t1.cid=sc.cid 12. 查询和”01”号的同学学习的课程完全相同的其他同学的学号和姓名#注意是和&#39;01&#39;号同学课程完全相同但非学习课程数相同的,这里我用左连接解决这个问题select t1.sid,sname from ( select sc.sid ,count(distinct sc.cid) from ( select cid from sc where sid=&#39;01&#39; )t1 #选出01的同学所学的课程 left join sc on t1.cid=sc.cid group by sc.sid having count(distinct sc.cid)= (select count(distinct cid) from sc where sid = &#39;01&#39;) )t1 left join student on t1.sid=student.sid where t1.sid!=&#39;01&#39; 13. 把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；#暂跳过update题目 14. 查询没学过”张三”老师讲授的任一门课程的学生姓名select sname from student where sid not in ( select distinct sid from sc left join course on sc.cid=course.cid left join teacher on course.tid=teacher.tid where tname=&#39;张三&#39; ) 15. 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩select t1.sid,sname,avg_score from ( select sid,count(if(score&lt;60,cid,null)),avg(score) as avg_score from sc group by sid having count(if(score&lt;60,cid,null)) &gt;=2 )t1 left join student on t1.sid=student.sid 16. 检索”01”课程分数小于60，按分数降序排列的学生信息select sid,if(cid=&#39;01&#39;,score,100)from sc where if(cid=&#39;01&#39;,score,100)&lt;60 order by if(cid=&#39;01&#39;,score,100) desc 17. 按平均成绩从高到低显示所有学生的平均成绩select sid,avg(score) from sc group by sid order by avg(score) desc 18. 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率select sc.cid ,cname ,max(score) as max_score ,min(score) as min_score ,avg(score) as avg_score ,count(if(score&gt;=60,sid,null))/count(sid) as pass_rate from sc left join course on sc.cid=course.cid group by sc.cid 19. 按各科平均成绩从低到高和及格率的百分数从高到低顺序#这里先按照平均成绩排序，再按照及格百分数排序， select cid ,avg(score) as avg_score ,count(if(score&gt;=60,sid,null))/count(sid) as pass_rate from sc group by cid order by avg_score,pass_rate desc 20. 查询学生的总成绩并进行排名select sid ,sum(score) as sum_score from sc group by sid order by sum_score desc 21. 查询不同老师所教不同课程平均分从高到低显示select tid ,avg(score) as avg_score from course left join sc on course.cid=sc.cid group by tid order by avg_score desc 22. 查询所有课程的成绩第2名到第3名的学生信息及该课程成绩select sid,rank_num,score,cid from ( select rank() over(partition by cid order by score desc) as rank_num ,sid ,score ,cid from sc )t where rank_num in (2,3) 23. 统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比select sc.cid ,cname ,count(if(score between 85 and 100,sid,null))/count(sid) ,count(if(score between 70 and 85,sid,null))/count(sid) ,count(if(score between 60 and 70,sid,null))/count(sid) ,count(if(score between 0 and 60,sid,null))/count(sid) from sc left join course on sc.cid=course.cid group by sc.cid,cname 24. 查询学生平均成绩及其名次select sid ,avg_score ,rank() over (order by avg_score desc) from ( select sid ,avg(score) as avg_score from sc group by sid )t 25. 查询各科成绩前三名的记录select sid,cid,rank1from ( select cid ,sid ,rank() over(partition by cid order by score desc) as rank1 from sc )twhere rank1&lt;=3 26. 查询每门课程被选修的学生数select count(sid) ,cid from sc group by cid 27. 查询出只选修了一门课程的全部学生的学号和姓名select sid from sc group by sid having count(cid) =1 28. 查询男生、女生人数select ssex ,count(distinct sid)from studentgroup by ssex 29. 查询名字中含有”风”字的学生信息select sid,sname from student where sname like &#39;%风%&#39; 30. 查询同名同性学生名单，并统计同名人数select ssex ,sname ,count(sid) from student group by ssex,sname having count(sid)&gt;=2 31. 查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)select sid,sname,sage from student where year(sage)=1990 32. 查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列select cid,avg(score) as avg_score from sc group by cid order by avg_score,cid desc 33. 查询不及格的课程，并按课程号从大到小排列select cid,sid,score from sc where score&lt;60 order by cid desc,sid 34. 查询课程编号为”01”且课程成绩在60分以上的学生的学号和姓名；select sid,cid,scorefrom scwhere cid=&#39;01&#39; and score&gt;60 35. 查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩select sc.sid,sname,cname,score from sc left join course style=&quot;font-weight: 600;&quot;&gt;=course.cid left join teacher style=&quot;font-weight: 600;&quot;&gt;=teacher.tid left join student style=&quot;font-weight: 600;&quot;&gt;=student.sid where tname=&#39;张三&#39; order by score desc limit 1; 36. 查询每门功课成绩最好的前两名select cid,sid,rank1 from ( select cid ,sid ,rank() over(partition by cid order by score desc) as rank1 from sc )t where rank1 &lt;=2 37. 统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列select cid ,count(sid) as cnt from sc group by cid having cnt&gt;=5 order by count(sid) desc,cid 38. 检索至少选修两门课程的学生学号select sid ,count(cid) from sc group by sid having count(cid)&gt;=2 39. 查询选修了全部课程的学生信息select sid ,count(cid) from sc group by sid having count(cid)=(select count(distinct cid) from sc) 40. 查询各学生的年龄select sid,sname,year(curdate())-year(sage) as sage from student 41 查询本周过生日的学生select sid,sname,sage from student where weekofyear(sage)=weekofyear(curdate()) 42. 查询下周过生日的学生select sid,sname,sage from student where weekofyear(sage) = weekofyear(date_add(curdate(),interval 1 week)) 43 查询本月过生日的学生select sid,sname,sage from student where month(sage) = month(curdate()) 44. 查询下月过生日的学生select sid,sname,sage from student where month(date_sub(sage,interval 1 month)) = month(curdate())","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"海盗分金问题问题","slug":"海盗分金问题","date":"2020-03-21T11:42:55.000Z","updated":"2020-03-23T13:50:59.885Z","comments":true,"path":"2020/03/21/海盗分金问题/","link":"","permalink":"http://smilecoc.vip/2020/03/21/海盗分金问题/","excerpt":"","text":"有5个海盗有100枚金币，但这5个人没有老大，不知道怎么分这100枚金币。不过5个人都绝顶聪明，他们决定：1.抽签，决定12345五个号码，2.由1号提分配方案，大家一起举手表决，超过半数同意则通过；否则被扔进大海里喂鲨鱼；3.1号死了由2号提分配方案，四个人表决有超过半数人同意，则通过，否则仍旧被扔进大海里喂鲨鱼；4.以此类推—– 假定：每个海盗都是一样的聪明，都可以做出最理性的决策，那么最终这五个海盗分得的金币的 答案分析： 1号海盗分给3号1枚金币，4号或5号2枚金币，自己则独得97枚金币，即分配方案为（97，0，1，2，0）或（97，0，1，0，2）。 现来看如下各人的理性分析： 5号海盗：因为他是最安全的，没有被扔下大海的风险，因此他的策略也最为简单，即最好前面的人全都死光光，那么他就可以独得这100枚金币了。4号海盗：他的生存机会完全取决于前面还有人存活着，因为如果1号到3号的海盗全都喂了鲨鱼，那么在只剩4号与5号的情况下，不管4号提出怎样的分配方案，5号一定都会投反对票来让4号去喂鲨鱼，以独吞全部的金币。哪怕4号为了保命而讨好5号，提出（0，100）这样的方案让5号独占金币，但是5号还有可能觉得留着4号有危险，而投票反对以让其喂鲨鱼。因此理性的4号是不应该冒这样的风险，把存活的希望寄托在5号的随机选择上的，他惟有支持3号才能绝对保证自身的性命。3号海盗：他经过上述的逻辑推理之后，就会提出（100，0，0）这样的分配方案，因为他知道4号哪怕一无所获，也还是会无条件的支持他而投赞成票的，那么再加上自己的1票就可以使他稳获这100金币了。2号海盗：也经过推理得知了3号的分配方案，那么他就会提出（98，0，1，1）的方案。因为这个方案相对于3号的分配方案，4号和5号至少可以获得1枚金币，理性的4号和5号自然会觉得此方案对他们来说更有利而支持2号，不希望2号出局而由3号来进行分配。这样，2号就可以屁颠屁颠的拿走98枚金币了。1号海盗：经过一番推理之后也洞悉了2号的分配方案。他将采取的策略是放弃2号，而给3号1枚金币，同时给4号或5号2枚金币，即提出（97，0，1，2，0）或（97，0，1，0，2）的分配方案。由于1号的分配方案对于3号与4号或5号来说，相比2号的方案可以获得更多的利益，那么他们将会投票支持1号，再加上1号自身的1票，97枚金币就可轻松落入1号的腰包了。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://smilecoc.vip/tags/题解/"}],"author":"smilecoc"},{"title":"双蛋问题","slug":"双蛋问题","date":"2020-03-20T12:56:55.000Z","updated":"2020-03-23T13:51:46.321Z","comments":true,"path":"2020/03/20/双蛋问题/","link":"","permalink":"http://smilecoc.vip/2020/03/20/双蛋问题/","excerpt":"","text":"问题：奥林匹克大厦楼层高100层，当楼层低时，从楼上扔下鸡蛋不会碎，当楼层高时，从楼上扔下鸡蛋会破碎。现在你有两个鸡蛋，你扔多少次，可以计算得出鸡蛋不会碎的楼层？ 方式一：从一层开始扔，每层递增，那么每次增加1，最多试100次就出结果了。结果：最少1次就碎，最多100次碎。同时这个是在只有一个鸡蛋下的最优解最终的次数的结果区间为(1， 100) 方式二：平衡二叉树法每次取中间值楼层，如：50,25,13,7,4,2,1。如果第一次取50碎了，那说明临界点在50以内，就剩下一个鸡蛋，又开始第一种方式。最终的次数的结果区间为(7， 50)为了最优反向取，如：1,2,4,7……。最优1次就碎，最差75碎了，50没碎，那么就是(1,8+24)。最终的次数的结果区间为(1， 32) 方式三：假设我从N层扔，每次楼层一样,那么：N x N &gt;= 100, N取10层，如：10,20,30,40……100，一共10份。如果第一次扔10碎了，说明区间在1到10直接。最差的结果在100层扔碎了，区间在91层到99层之间。既(1+9, 10+9)。最终的次数的结果区间为(10， 19) 方式四：最优方案递归不过二分查找似乎并没有对我们解决问题有什么特别好的启发，我们只好另辟蹊径。我们可不可以通过 分而治之 的思想来解决这个问题呢？ 首先，基线条件很好确定： 在有 2 个鸡蛋的情况下，如果只有一层楼，只需要试一次；如果有两层楼，只需要试两次；如果没有楼，那就干脆不用试了（看似是废话，但是是很重要的边界条件）。如果只有 1 个鸡蛋，只能老老实实从下往上尝试，也就是在最坏的情况下，有几层楼就要试几次。接下来，我们就要思考递归条件了。如何能将问题简化。 令在有 2 个鸡蛋时，最坏的情况下，N 层楼所需要尝试的最少次数为 TN。 假设总共有 N 层楼，我们在第 K 层楼进行一次尝试。那么此时，就会分成两种情况： 鸡蛋在 K 层碎掉了，也就说明临界楼层在 K 层以下。但是此时，我们只剩下 1 个鸡蛋，最坏的情况下还要检测 K−1 次才能找到临界楼层鸡蛋在 K 层没有碎，临界楼层在 K 层以上。此时我们还是有 2 个鸡蛋，还剩下 N−K 层楼需要检测，那么最坏的情况下，还需要检测 TN−K 次。很显然 N−K 要比 N 少，我们顺利实现对问题的简化。最坏的情况显然是 K−1 和 TN−K 两个数的最大的那一个再加上 1，因为我们先试了一次。这个最大的数，就是 TN。 不过这里面有一个 K 是不能确定的。为了找到合适的 K，我们需要把 K 从 1 到 N 的情况全部计算出来，找到使得 TN 最小的情况即可。 用代码来解决这个问题就是： def two_egg(n: int) -&gt; int: &quot;&quot;&quot; 双蛋问题的递归求解 :param n: 楼层数 :return: 最坏情况下，找到临界楼层所需最少尝试次数 &quot;&quot;&quot; if n == 0: # 没有楼就不需要试 return 0 elif n == 1: # 有一层楼，试一次 return 1 result_list = [] for k in range(1, n + 1): # 在每一层都试一下 result_list.append(max(k - 1, two_egg(n - k)) + 1) # 把每一层的情况都记录下来 return min(result_list) # 最好的结果就是我们想要的 # 用 1 到 11 的数字测试，不用 100 是因为电脑性能不够，测到 11 是因为 10 和 11 的结果不同 for f in range(1, 12): print(f&#39;{f} -------&gt; {two_egg(f)}&#39;) 递归法解决普遍双蛋问题用二分查找，可以解决鸡蛋数目不限的情况，递归查找可以解决只有 2 个鸡蛋的情况。现在，我们把问题进一步扩展：如果我们有 M 个鸡蛋，N 层楼，在最坏的情况下，至少需要测试多少次能够找到临界楼层？ 基线条件根上面的差不多一样： 不管有多少个鸡蛋，如果只有一层楼，只需要试一次；如果没有楼，那就干脆不用试了。如果只有 1 个鸡蛋，只能老老实实从下往上尝试，也就是在最坏的情况下，有几层楼就要试几次。递归条件其实也很类似，只是因为鸡蛋数目的引入，会稍微复杂一丁丁点点。 令在有 M 个鸡蛋时，最坏的情况下，N 层楼所需要尝试的最少次数为 TM, N。 依旧假设总共有 N 层楼，我们在第 K 层楼进行一次尝试。那么此时，还是会分成两种情况： 鸡蛋在 K 层碎掉了，也就说明临界楼层在 K 层以下。但是此时，我们只剩下 M−1 个鸡蛋，最坏的情况下还要检测 TM−1, K−1 次才能找到临界楼层鸡蛋在 K 层没有碎，临界楼层在 K 层以上。此时我们还是有 M 个鸡蛋，还剩下 N−K 层楼需要检测，那么最坏的情况下，还需要检测 TM, N−K 次上面的两种情况，要么简化了鸡蛋数量，要么简化了楼层数量，最终都可以通过递归来找到答案。最终的结果需要是 TM−1, N 和 TM, N−K 这两个数中最大的那一个加上 1，因为我们最开始的时候在 K 层测试了一下。 同样地，我们需要遍历测试当 K 为 1 到 N 时的各种情况，取其中所需步骤最少的，就是我们要的结果。 用代码表示就是： def two_egg_general(m: int, n: int) -&gt; int: &quot;&quot;&quot; 普遍双蛋问题的解决 :param m: 鸡蛋数量 :param n: 楼层总层数 :return: 最糟糕的情况下，找到临界楼层所需最少尝试数目 &quot;&quot;&quot; if n == 0: # 如果没有楼，不需要试 return 0 elif n == 1: # 只有 1 层楼，试一次就足够 return 1 if m == 1: # 只有 1 个蛋，有几层楼就要使几次 return n result_list = [] for k in range(1, n + 1): result_list.append(max(two_egg_general(m - 1, k - 1), two_egg_general(m, n - k)) + 1) return min(result_list) for i in range(1, 12): for j in range(1, 12): print(f&#39;({i}, {j}) --&gt; {two_egg_general(i, j)}&#39;, end=&#39; | &#39;) print()","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://smilecoc.vip/tags/题解/"}],"author":"smilecoc"},{"title":"Pandas笔记","slug":"pandas笔记","date":"2020-03-15T15:46:34.000Z","updated":"2020-03-16T15:23:35.665Z","comments":true,"path":"2020/03/15/pandas笔记/","link":"","permalink":"http://smilecoc.vip/2020/03/15/pandas笔记/","excerpt":"","text":"pandas数据选取Pandas是作为Python数据分析著名的工具包，提供了多种数据选取的方法，方便实用。本文主要介绍Pandas的几种数据选取的方法。Pandas中，数据主要保存为Dataframe和Series是数据结构，这两种数据结构数据选取的方式基本一致，本文主要以Dataframe为例进行介绍。在Dataframe中选取数据大抵包括3中情况： 1）行（列）选取（单维度选取）：df[]。这种情况一次只能选取行或者列，即一次选取中，只能为行或者列设置筛选条件（只能为一个维度设置筛选条件）。 2）区域选取（多维选取）：df.loc[]，df.iloc[]，df.ix[]。这种方式可以同时为多个维度设置筛选条件。 3）单元格选取（点选取）：df.at[]，df.iat[]。准确定位一个单元格。 首先创建原始数据 import pandas as pd import numpy as np data = {&#39;name&#39;: [&#39;Joe&#39;, &#39;Mike&#39;, &#39;Jack&#39;, &#39;Rose&#39;, &#39;David&#39;, &#39;Marry&#39;, &#39;Wansi&#39;, &#39;Sidy&#39;, &#39;Jason&#39;, &#39;Even&#39;], &#39;age&#39;: [25, 32, 18, np.nan, 15, 20, 41, np.nan, 37, 32], &#39;gender&#39;: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0], &#39;isMarried&#39;: [&#39;yes&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;no&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;no&#39;]} labels = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;] df = pd.DataFrame(data, index=labels) 目前的df的数据为： name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no d Rose NaN 1 yes e David 15.0 0 no f Marry 20.0 1 no g Wansi 41.0 0 no h Sidy NaN 0 yes i Jason 37.0 1 no j Even 32.0 0 no行（列）选取：df[]行（列）选取是在单一维度上进行数据的选取，即以行为单位进行选取或者以列为单位进行选取。Dataframe对象的行有索引（index），默认情况下是[0,1,2，……]的整数序列，也可以自定义添加另外的索引，例如上面的labels，（为区分默认索引和自定义的索引，在本文中将默认索引称为整数索引，自定义索引称为标签索引）。Dataframe对象的每一列都有列名，可以通过列名实现对列的选取。 1）选取行选取行的方式包括三种：整数索引切片、标签索引切片和布尔数组。a）整数索引切片：前闭后开选取第一行： &gt;&gt;&gt; df[0:1] name age gender isMarried a Joe 25.0 1 yes 选取前两行： &gt;&gt;&gt; df[0:2] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes b）标签索引切片：前闭后闭选取第一行： &gt;&gt;&gt; df[:&#39;a&#39;] name age gender isMarried a Joe 25.0 1 yes 选取前两行： &gt;&gt;&gt; df[&#39;a&#39;:&#39;b&#39;] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes 注意：整数索引切片是前闭后开，标签索引切片是前闭后闭，这点尤其要注意。 c）布尔数组选取前三行 &gt;&gt;&gt; df[[True,True,True,False,False,False,False,False,False,False]] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no 选取所有age大于30的行 &gt;&gt;&gt; df[[each&gt;30 for each in df[&#39;age&#39;]]] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 通过布尔数组的方式，又可以衍生出下面的选取方式：选取所有age大于30的行（更方便且更经常使用） &gt;&gt;&gt; df[df[&#39;age&#39;]&gt;30] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 选取出所有age大于30，且isMarried为no的行 &gt;&gt;&gt; df[(df[&#39;age&#39;]&gt;30) &amp; (df[&#39;isMarried&#39;]==&#39;no&#39;)] name age gender isMarried g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 选取出所有age为20或32的行 &gt;&gt;&gt; df[(df[&#39;age&#39;]==20) | (df[&#39;age&#39;]==32)] name age gender isMarried b Mike 32.0 0 yes f Marry 20.0 1 no j Even 32.0 0 no 注意：像上面这种通过多个布尔条件判断的情况，多个条件最好（一定）用括号括起来，否则非常容易出错。 2）列选取列选取方式也有三种：标签索引、标签列表、Callable对象 a）标签索引：选取单个列 选取name列所有数据 &gt;&gt;&gt; df[&#39;name&#39;] a Joe b Mike c Jack d Rose e David f Marry g Wansi h Sidy i Jason j Even Name: name, dtype: object b）标签列表：选取多个列 选取name和age两列数据 &gt;&gt;&gt; df[[&#39;name&#39;,&#39;age&#39;]] name age a Joe 25.0 b Mike 32.0 c Jack 18.0 d Rose NaN e David 15.0 f Marry 20.0 g Wansi 41.0 h Sidy NaN i Jason 37.0 j Even 32.0 c）callable对象 选取第一列 &gt;&gt;&gt; df[lambda df: df.columns[0]] a Joe b Mike c Jack d Rose e David f Marry g Wansi h Sidy i Jason j Even Name: name, dtype: object 区域选取区域选取可以从多个维度（行和列）对数据进行筛选，可以通过df.loc[]，df.iloc[]，df.ix[]三种方法实现。采用df.loc[]，df.iloc[]，df.ix[]这三种方法进行数据选取时，方括号内必须有两个参数，第一个参数是对行的筛选条件，第二个参数是对列的筛选条件，两个参数用逗号隔开。df.loc[]，df.iloc[]，df.ix[]的区别如下： * df.loc[]只能使用标签索引，不能使用整数索引，通过便签索引切边进行筛选时，前闭后闭。 * df.iloc[]只能使用整数索引，不能使用标签索引，通过整数索引切边进行筛选时，前闭后开。； * df.ix[]既可以使用标签索引，也可以使用整数索引。 下面分别通过实例演示这三种方法。 df.loc[] 1）对行进行选取 选取索引为‘a’的行： &gt;&gt;&gt; df.loc[&#39;a&#39;, :] name Joe age 25 gender 1 isMarried yes Name: a, dtype: object 选取索引为‘a’或‘b’或‘c’的行 &gt;&gt;&gt; df.loc[[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], :] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no 选取从‘a’到‘d’的所有行（包括‘d’行） &gt;&gt;&gt; df.loc[&#39;a&#39;:&#39;d&#39;, :] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no d Rose NaN 1 yes 用布尔数组选取前3行 &gt;&gt;&gt; df.loc[[True,True,True,False,False,False], :] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no 选取所有age大于30的行 &gt;&gt;&gt; df.loc[df[&#39;age&#39;]&gt;30,:] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 也可以使用下面两方法： &gt;&gt;&gt; df.loc[df.loc[:,&#39;age&#39;]&gt;30, :] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no &gt;&gt;&gt; df.loc[df.iloc[:,1]&gt;30, :] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 用callable对象选取age大于30的所有行 &gt;&gt;&gt; df.loc[lambda df:df[&#39;age&#39;] &gt; 30, :] name age gender isMarried b Mike 32.0 0 yes g Wansi 41.0 0 no i Jason 37.0 1 no j Even 32.0 0 no 2）对列选取 输出所有人的姓名（选取name列） &gt;&gt;&gt; df.loc[:, &#39;name&#39;] a Joe b Mike c Jack d Rose e David f Marry g Wansi h Sidy i Jason j Even Name: name, dtype: object输出所有人的姓名和年龄（选取name和age列） &gt;&gt;&gt; df.loc[:, &#39;name&#39;:&#39;age&#39;] name age a Joe 25.0 b Mike 32.0 c Jack 18.0 d Rose NaN e David 15.0 f Marry 20.0 g Wansi 41.0 h Sidy NaN i Jason 37.0 j Even 32.0 输出所有人的姓名、年龄、婚否（选取name、age、isMarried列） &gt;&gt;&gt; df.loc[:, [&#39;name&#39;,&#39;age&#39;,&#39;isMarried&#39;]] name age isMarried a Joe 25.0 yes b Mike 32.0 yes c Jack 18.0 no d Rose NaN yes e David 15.0 no f Marry 20.0 no g Wansi 41.0 no h Sidy NaN yes i Jason 37.0 no j Even 32.0 no用布尔数组的方式选取前3列 &gt;&gt;&gt; df.loc[:, [True,True,True,False]] name age gender a Joe 25.0 1 b Mike 32.0 0 c Jack 18.0 1 d Rose NaN 1 e David 15.0 0 f Marry 20.0 1 g Wansi 41.0 0 h Sidy NaN 0 i Jason 37.0 1 j Even 32.0 0 3）同时对行和列进行筛选 输出年龄大于30的人的姓名和年龄 &gt;&gt;&gt; df.loc[df[&#39;age&#39;]&gt;30,[&#39;name&#39;,&#39;age&#39;]] name age b Mike 32.0 g Wansi 41.0 i Jason 37.0 j Even 32.0 输出行名为‘Mike’或‘Marry’的姓名和年龄 &gt;&gt;&gt; df.loc[(df[&#39;name&#39;]==&#39;Mike&#39;) |(df[&#39;name&#39;]==&#39;Marry&#39;),[&#39;name&#39;,&#39;age&#39;]] name age b Mike 32.0 f Marry 20.0 3.2 df.iloc[] 1）行选取 选取第2行 &gt;&gt;&gt; df.iloc[1, :] name Mike age 32 gender 0 isMarried yes Name: b, dtype: object 选取前3行 &gt;&gt;&gt; df.iloc[:3, :] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no 选取第2行、第4行、第6行 &gt;&gt;&gt; df.iloc[[1,3,5],:] name age gender isMarried b Mike 32.0 0 yes d Rose NaN 1 yes f Marry 20.0 1 no 通过布尔数组选取前3行 &gt;&gt;&gt; df.iloc[[True,True,True,False,False,False], :] name age gender isMarried a Joe 25.0 1 yes b Mike 32.0 0 yes c Jack 18.0 1 no 2）列选取 选取第2列 &gt;&gt;&gt; df.iloc[:, 1] a 25.0 b 32.0 c 18.0 d NaN e 15.0 f 20.0 g 41.0 h NaN i 37.0 j 32.0 Name: age, dtype: float64 选取前3列 &gt;&gt;&gt; df.iloc[:, 0:3] name age gender a Joe 25.0 1 b Mike 32.0 0 c Jack 18.0 1 d Rose NaN 1 e David 15.0 0 f Marry 20.0 1 g Wansi 41.0 0 h Sidy NaN 0 i Jason 37.0 1 j Even 32.0 0 选取第1列、第3列和第4列 &gt;&gt;&gt; df.iloc[:, [0,2,3]] name gender isMarried a Joe 1 yes b Mike 0 yes c Jack 1 no d Rose 1 yes e David 0 no f Marry 1 no g Wansi 0 no h Sidy 0 yes i Jason 1 no j Even 0 no 通过布尔数组选取前3列 &gt;&gt;&gt; df.iloc[:,[True,True,True,False]] name age gender a Joe 25.0 1 b Mike 32.0 0 c Jack 18.0 1 d Rose NaN 1 e David 15.0 0 f Marry 20.0 1 g Wansi 41.0 0 h Sidy NaN 0 i Jason 37.0 1 j Even 32.0 0 3）同时选取行和列 选取第2行的第1列、第3列、第4列 &gt;&gt;&gt; df.iloc[1, [0,2,3]] name Mike gender 0 isMarried yes Name: b, dtype: object 选取前3行的前3列 &gt;&gt;&gt; df.iloc[:3, :3] name age gender a Joe 25.0 1 b Mike 32.0 0 c Jack 18.0 1 3.3 df.ix[] df.ix[]既可以通过整数索引进行数据选取，也可以通过标签索引进行数据选取，换句话说，df.ix[]是df.loc[]和df.iloc[]的功能集合，且在同义词选取中，可以同时使用整数索引和标签索引。 选取第3行的name数据 &gt;&gt;&gt; df.ix[2,&#39;name&#39;] &#39;Jack&#39; 选取a行、c行的第1列，第2列和第4列数据 &gt;&gt;&gt; df.ix[[&#39;a&#39;,&#39;c&#39;], [0,1,3]] name age isMarried a Joe 25.0 yes c Jack 18.0 no `` 选取所有未婚者的姓名和年龄 ```python &gt;&gt;&gt; df.ix[df[&#39;isMarried&#39;]==&#39;no&#39;,[&#39;name&#39;,&#39;age&#39;]] name age c Jack 18.0 e David 15.0 f Marry 20.0 g Wansi 41.0 i Jason 37.0 j Even 32.0 单元格选取单元格选取包括df.at[]和df.iat[]两种方法。df.at[]和df.iat[]使用时必须输入两个参数，即行索引和列索引，其中df.at[]只能使用标签索引，df.iat[]只能使用整数索引。df.at[]和df.iat[]选取的都是单个单元格（单行单列），所以返回值都为基本数据类型。 1 df.at[]选取b行的name列 &gt;&gt;&gt; df.at[&#39;b&#39;,&#39;name&#39;] &#39;Mike&#39; 2 df.iat[]选取第2行第1列 &gt;&gt;&gt; df.iat[1,0] &#39;Mike&#39; 拓展与总结* 1）选取某一整行（多个整行）或某一整列（多个整列）数据时，可以用df[]、df.loc[]、df.iloc[]，此时df[]的方法书写要简单一些。 * 2）进行区域选取时，如果只能用标签索引，则使用df.loc[]或df.ix[]，如果只能用整数索引，则用df.iloc[]或df.ix[]。不过我看到有资料说，不建议使用df.ix[],因为df.loc[]和df.iloc[]更精确（有吗？我没理解精确在哪，望告知）。 * 3）如果选取单元格，则df.at[]、df.iat[]、df.loc[]、df.iloc[]都可以，不过要注意参数。 * 4）选取数据时，返回值存在以下情况： 如果返回值包括单行多列或多行单列时，返回值为Series对象； 如果返回值包括多行多列时，返回值为DataFrame对象； 如果返回值仅为一个单元格（单行单列）时，返回值为基本数据类型，例如str，int等。 5）df[]的方式只能选取行和列数据，不能精确到单元格，所以df[]的返回值一定DataFrame或Series对象。 * 6）当使用DataFrame的默认索引（整数索引）时，整数索引即为标签索引。例如，使用上面的data实例化一个DataFrame对象： &gt;&gt;&gt; df2 = pd.DataFrame(data) &gt;&gt;&gt; df2.loc[1,&#39;name&#39;] &#39;Mike&#39; &gt;&gt;&gt; df2.iloc[1,0] &#39;Mike&#39;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://smilecoc.vip/tags/Pandas/"}],"author":"smilecoc"},{"title":"Git语句大全","slug":"Git语句大全","date":"2020-03-12T14:22:30.000Z","updated":"2020-06-16T16:29:01.889Z","comments":true,"path":"2020/03/12/Git语句大全/","link":"","permalink":"http://smilecoc.vip/2020/03/12/Git语句大全/","excerpt":"","text":"一、Git 配置相关如果你首次使用 Git，那刚开始首先是需要配置各种身份信息的，这样当你提交相关任务的时候，别人才能知道这个 commit 是谁提交的。 （1）、Git 最小配置1、配置全局账户，也就是该账户对所有的 Git 仓库都有效 git config --global user.name &#39;你的账户名称&#39;git config --global user.email &#39;你的 Email&#39;2、配置局部账户，也就是该账户只对当前 Git 仓库有效 git config --local user.name &#39;你的账户名称&#39; git config --local user.email &#39;你的 Email&#39;注意，不同点就是一个参数是 global（全局），一个是 local(本地) （2）、查看相关配置情况配置了之后，显然有时候是需要查看我们当前配置的相关情况的，可以使用如下命令 1、查看 global 类型的配置情况 git config --global --list2、查看某个仓库下的配置情况 git config --local --list二、本地基本操作这部分命令有点多，也是使用的最频繁的命令了，待我一一列举出来，建议收藏 （1）、基本操作1、查看变更情况 git status2、查看当前工作在哪个分支上 git branch -v3、切换到指定分支 git checkout 指定分支的名称4、把当前目录及其子目录下所有变更都加入到暂存区 git add . // 注意，add 后面是一个 &#39;.&#39;；5、把仓库内所有变更都假如到暂存区 git add -A6、把指定文件添加到暂存区 git add 文件1 文件2 ... 文件n7、创建正式的 commit，也就是把当前的数据提交上去 git commit（二）、比较差异1、比较某文件工作区和暂存区的差异 git diff 某文件2、比较某文件暂存区和 HEAD 的差异 git diff --cache 某文件3、比较工作区和暂存区的所有差异 git diff4、比较暂存区和 HEAD 的所有差异 git diff --cache（3）、暂存区与工作区之间回滚1、把工作区指定文件恢复成和暂存区一样 git checkout 文件1 文件2 ... 文件n2、把暂存区指定文件回复和 HEAD 一样 git reset 文件1 文件2 ... 文件n3、把暂存区和工作区所有文件恢复成和 HEAD 一样 git reset --hard4、用 difftool 比较任意两个 commit 的差异 git difftool commit1 commit2 注意，从工作区回滚到暂存区则用 checkout ，否则用 reset （四）、其他查看哪些文件没有被 Git 管控 git ls-files --others三、加塞临时任务处理1、把未处理完的变更先保存到 stash 中 git stash2、临时任务处理完后继续之前的工作 git stash pop // pop 相当于栈的出栈和入栈一样，把之前的任务弹出来或者git stash apply // 和 pop 不同的是， apply 相当于从栈顶把任务取出来，但是不过从栈中把任务移除3、查看所有的 stash git stash list4、取回某次 stash 的变更 git stash pop stash @{数字n}四、修改个人分支历史我们的仓库的内容每次变更执行 commit 的时候，都会生成一个新的 commit，不过有时候，我们不想产生新的 commit，而是想要通过修改之前的 commit 来变更仓库的内容，那么就可以使用如下命令了 1、修改最后一次 commit 1、在工作区中修改文件2、git add3、git commit --amend2|、修改中间的 commit(假设代号为 X) 1. git rebase -i X前面的一个 commit 的 id2. 在工作区修改文件3. git add4. git rebase --contiue 五、查看变更日志等1、当前分支各个 commit 用一行显示 git log --online2、显示最近的 n 个 commit git log -n3、用图示显示所有的分支历史 git log --online --graph --all4、查看涉及到某文件变更的所有 commit git log 某文件5、某文件各行最后修改对应的 commit 以及作者 git blame 某文件六、分支与标签1、创建新分支基于当前分支创建新分支 git branch 新分支基于指定分支创建新分支 git branch 新分支 已有分支基于某个 commit 创建分支 git branch 新分支 某个 commit 的id创建分支并且切换到该分支 git chechout -b 新分支2、列出分支列出本地分支 git branch -v列出本地和远端分支 git branch -av列出远端所有分支 git branch -rv列出名称符号某样式的远端分支 git branch -rv -l &#39;某样式&#39;3、删除分支安全删除本地某分支 git branch -d 要删除的分支强行删除本地分支 git branch -D 要删除的分支删除已合并到 master 分支的所有本地分支 git branch --merged master | grep -v &#39;^\\*\\| master&#39; | xargs -n 1 git branch -d删除远端 origin 已不存在的所有本地分支 git remote prune origin4、打标签从 commit 打上标签 git tag 标签名 commit 的id七、两分支之间的集成1、把 A 分支合入到当前分支，且为 merge 创建 commit git merge A分支2、把 A 分支合入到 B 分支，且为 Merge 创建 commit git merge A分支 B分支 3、把当前分支基于B分支做 rebase，以便把B分支合入到当前分支 git rebase B分支4、把A分支基于B分支做rebase，以便把B分支合入到A分支 git rebase B分支 A分支5、用 mergetool 解决冲突 git mergetool八、和远端交互1、列出所有 remote git remote -v2、增加 remote git remote add url地址3、删除 remote git remote remove remote的名称4、改变 remote 的name git remote rename 旧名称 新名称5、把远端所有分支和标签的变更都拉到本地 git fetch remote6、把远端分支的变更拉倒本地，且 merge 到本地分支 git pull remote名称 分支名关于 pull 和 fetch 的区别不懂可以看这篇文章从0学习Git：详解git pull和git fetch的区别 7、把本地分支 push 到远端 git push remote名称 分支名8、删除远端分支 git push remote --delete 远端分支名或者git push remote:远端分支名9、向远端提交指定标签 git push remote 标签名10、向远端提交所有标签 git push remote --tags","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://smilecoc.vip/tags/Git/"}],"author":"smilecoc"},{"title":"数据库设计范式","slug":"数据库设计范式","date":"2020-03-07T08:06:22.000Z","updated":"2020-07-08T16:45:20.065Z","comments":true,"path":"2020/03/07/数据库设计范式/","link":"","permalink":"http://smilecoc.vip/2020/03/07/数据库设计范式/","excerpt":"","text":"范式：英文名称是 Normal Form，它是英国人 E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的，范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。首先简单介绍下前三个范式，这也是目前设计数据库时的范式要求： 第一范式（1NF）强调的是列的原子性，即列不能够再分成其他几列。考虑这样一个表：【联系人】（姓名，性别，电话）如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。1NF 很好辨别，但是 2NF 和 3NF 就容易搞混淆。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。 第二范式（2NF）首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。 第三范式（3NF）在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。 首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。 其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。 第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。 但是需要注意的是，在实际的业务过程中，其实很多时候是不会严格按照范式来设计数据库。在实际的业务中数据库的性能是最重要的，所以有的时候不符合数据库的设计范式，产生冗余的数据，但是可以提高数据库的查询性能。举个例子来说：如果数据库中有活动名称这一个字段，是由年份，月份，活动名称以及地点组合而成的，按照第一范式的要求需要拆分成四列。但是如果实际需求中如果确定活动名称所包含的四列拆开都没有任何的业务需求，那么我们其实就可以直接保持活动名称这一列，这样在每次需要查询活动名称这一个字段时不需要先拼接再查询。同理，如果要符合2NF和3NF，设计的两表或者多表查询时必然会涉及连接语句，而连接操作会消耗大量资源与性能，所以有的时候直接将数据放在一张大表中以提高查询性能。所以实际设计时一定要结合实际，灵活处理 另外一些更高要求的范式： BC范式(BCNF)它构建在第三范式的基础上，如果关系模型R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R为BCNF的模式。假设仓库管理关系表(仓库号，存储物品号，管理员号，数量)，满足一个管理员只在一个仓库工作；一个仓库可以存储多种物品，则存在如下关系： (仓库号，存储物品号)——&gt;(管理员号，数量) (管理员号，存储物品号)——&gt;(仓库号，数量) 所以，(仓库号，存储物品号)和(管理员号，存储物品号)都是仓库管理关系表的候选码，表中唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库号)——&gt;(管理员号) (管理员号)——&gt;(仓库号) 即存在关键字段决定关键字段的情况，因此其不符合BCNF。把仓库管理关系表分解为两个关系表仓库管理表(仓库号，管理员号)和仓库表(仓库号，存储物品号，数量)，这样这个数据库表是符合BCNF的，并消除了删除异常、插入异常和更新异常。 第四范式(4NF)设R是一个关系模型，D是R上的多值依赖集合。如果D中存在多值依赖X-&gt;Y时，X必是R的超键，那么称R是第四范式的模式。 例如，职工表(职工编号，职工孩子姓名，职工选修课程)，在这个表中，同一个职工可能会有多个职工孩子姓名，同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如职工表一(职工编号，职工孩子姓名)，职工表二(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。 目前各范式的关系图如下所示： ![](/upload_image/blog 2003/1.webp)","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"微博批量自动取关","slug":"微博批量自动取关","date":"2020-03-07T07:54:45.389Z","updated":"2020-03-07T08:18:38.818Z","comments":true,"path":"2020/03/07/微博批量自动取关/","link":"","permalink":"http://smilecoc.vip/2020/03/07/微博批量自动取关/","excerpt":"","text":"之前偶然登陆微博发现微博里有60多个关注的对象，然而都不是自己关注的人(万恶的微博 🤔)，然后又没有发现全选 取关的按钮，于是做了个自动帮助我们取关的脚本，顺便练习一下selenium库的使用~废话不多说，上代码~ from selenium import webdriver import time from selenium.webdriver import ActionChains browser = webdriver.Chrome() #登陆 browser.get(&#39;http://weibo.com/login.php&#39;) #//*[@style] 查找所有包含style的所有元素，所有的属性要加@ browser.find_element_by_xpath(&#39;//*[@id=&quot;loginname&quot;]&#39;).clear() #输入登录账号 browser.find_element_by_xpath(&#39;//*[@id=&quot;loginname&quot;]&#39;).send_keys(&#39;Your ID&#39;) browser.find_element_by_xpath(&#39;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[2]/div/input&#39;).clear() time.sleep(1) #输入登陆密码 browser.find_element_by_xpath(&#39;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[2]/div/input&#39;).send_keys(&#39;your password&#39;) time.sleep(1) browser.find_element_by_xpath(&#39;//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[6]/a&#39;).click() time.sleep(1) browser.find_element_by_xpath(&#39;//*[@id=&quot;v6_pl_rightmod_myinfo&quot;]/div/div/div[2]/ul/li[1]/a/strong&#39;).click() time.sleep(1) #browser.find_element_by_link_text(&quot;设置&quot;) 通过文本定位元素 #取关数量 for cou in range(1,10): #定位悬停时的元素 ActionChains(browser).move_to_element(browser.find_element_by_xpath(&#39;//*[@id=&quot;Pl_Official_RelationMyfollow__95&quot;]/div/div/div/div[3]/ul/li[1]/div[1]/div[2]/div[5]/p/a[3]/em&#39;)).perform() time.sleep(2) browser.find_element_by_link_text(&quot;取消关注&quot;).click() time.sleep(1) #browser.find_element_by_xpath(&#39;//*[@id=&quot;layer_15660574768511&quot;]/div[2]/div[4]/a[1]&#39;).click() browser.find_element_by_link_text(&quot;确定&quot;).click() browser.quit() 整个流程中的问题主要有两个： 1.有一个鼠标悬停时才显示的取消关注界面，使用ActionChains(browser).move_to_element().perform()方法解决 2.最后还有一个确定窗口跳出来，之前以为是弹窗，但是后来发现其实并不是，直接定位元素就可以了","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"python其他","slug":"python其他","permalink":"http://smilecoc.vip/tags/python其他/"}],"author":"smilecoc"},{"title":"使用Python调用百度地图Api获取两地距离并打包为可执行程序","slug":"使用Python调用百度地图Api获取两地距离","date":"2020-03-07T07:41:11.095Z","updated":"2020-04-09T15:57:27.955Z","comments":true,"path":"2020/03/07/使用Python调用百度地图Api获取两地距离/","link":"","permalink":"http://smilecoc.vip/2020/03/07/使用Python调用百度地图Api获取两地距离/","excerpt":"","text":"最近新接了一个需求需要获取两个地址间的步行距离，可以通过调用高德地图，百度地图的api接口实现这些功能，特此记录。 1.获取百度api接口首先需要在百度的公众平台http://lbsyun.baidu.com/上点击控制台，如果是新用户的话需要进行注册和验证。注册和验证完毕后可以点击创建应用，填写应用名称等相关信息，应用类型根据需要进行设置，有浏览器端和服务器端两种。在这里特别说明的是，在IP白名单框里最好设置为：0.0.0.0/0，因为有时候把自己己的IP地址输进去可能也不行。创建应用完成后我们就可以得到刚刚创建的应用的密钥（AK） 2.获取起始地点的地理编码首先是找到获取步行距离的官方文档http://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1，但是发现对应的api接口里需要起始地点的地理编码，所以首先需要获取对应起始位置的地理编码http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding。如果有其他的需求，例如找路线规划等等都可以通过说明文档进行修改 def getapiurl(myaddress): url=r&quot;http://api.map.baidu.com/geocoding/v3/?address={}&amp;output=json&amp;ak={}&quot;.format(myaddress,myAK)#说明文档里给出的api接口 print(url) return url def getPosition(url): &#39;&#39;&#39;返回经纬度信息&#39;&#39;&#39; res = requests.get(url) json_data = json.loads(res.text) if json_data[&#39;status&#39;] == 0: lat = json_data[&#39;result&#39;][&#39;location&#39;][&#39;lat&#39;] # 纬度 lng = json_data[&#39;result&#39;][&#39;location&#39;][&#39;lng&#39;] # 经度 else: print(&quot;Error output!&quot;) return json_data[&#39;status&#39;] return lat, lng 3.获取起始地点的步行距离def getdistance(startlat,startlng,endlat,endlng): #{: .6f}保留小数点后六位 distanceurl=r&quot;http://api.map.baidu.com/directionlite/v1/walking?origin={:.6f},{:.6f}&amp;destination={:.6f},{:.6f}&amp;ak={}&quot;.format(startlat,startlng,endlat,endlng,myAK) res = requests.get(distanceurl) dis_json_data = json.loads(res.text) if dis_json_data[&#39;status&#39;] == 0: distance=dis_json_data[&#39;result&#39;][&#39;routes&#39;][0][&#39;distance&#39;] print(distance) 这里通过api获取的json文件中的结构与说明文档中的结构有一些出入，所以还是要按照实际的情况灵活修改呀。 这样主体程序就完成了，接着加上读取数据和用户交互窗口 4.利用pandas读取并处理数据def get_address(file_path): data=pd.read_excel(file_path) startaddress=data[&#39;地区&#39;]+data[&#39;出发行政区域&#39;]+data[&#39;出发地址&#39;] endaddress=data[&#39;地区&#39;]+data[&#39;到达行政区域&#39;]+data[&#39;到达地址&#39;] distance=[] #遍历series输入需要查询的起始地点 for i in range(1,len(startaddress)+1): startlat, startlng = getPosition(startaddress[i-1]) endlat, endlng = getPosition(endaddress[i-1]) #将输出结果拼接为list distance.append(getdistance(startlat, startlng, endlat, endlng)) dfdistance=pd.DataFrame(distance) #使用concat拼接两个dataframe，其中axis=1表示横向拼接，如果不加此参数或者为0表示纵向拼接 result=pd.concat([data,dfdistance],axis=1) #更改列名称 result.rename(columns={0: &#39;distance&#39;}, inplace=True) result.to_excel(parent_path + &#39;/结果文件.xlsx&#39;,index=None) 这里因为api接口只能一个一个距离导入，所以首先将结果拼接成list再与之前的数组利用concat拼接。在使用pandas时很重要的一点是pandas的最小使用维度在一列数据中，所以只有比较好的数据结构时使用pandas才会比较方便 4.用户交互窗口最后是利用tkinter实现用户交互窗口，实现一个窗口可以让用户选取文件并将生成的结果文件保存到同一文件夹下 #获取文件路径 def get_filename(): root = tk.Tk() root.withdraw() #file_path为文件的路径，parent_path为文件所在的文件夹路径 file_path = filedialog.askopenfilename() parent_path = os.path.dirname(file_path) return file_path, parent_path实现的效果如下：![](/upload_image/blog 2004/1.png)这样整个程序就 完工了! 接下来是将生成的数据打包为直接可执行的文件，因为一般用户不会自己装python和配置。1.首先按下win+R键，输入cmd打开命令运行窗口，输入cd+文件路径进入指定的文件夹![](/upload_image/blog 2004/2.png)2.安装pyinstaller库： pip install pyinstaller这里我之前已经安装过pyinstaller库，所以直接跳过这一步如果已经安装过pyinstaller库，那么在上一步时就要进到pyinstaller库安装的那一个文件夹运行。 3.打包： python pyinstaller.py -F baidu_map_distance.py这里要注意：一是baidu_map_distance.py为要打包的程序名称。第二是因为现在我的程序是放在安装 pyinstaller的文件夹下的，所以填的是相对路径，如果是要打包其他文件夹中的程序，需要使用绝对路径三是F的含义为将原文件打包为exe文件，还有其他几个可选参数 -F的含义为将原文件打包为exe文件 -D：创建一个目录，包含exe文件，但会依赖很多文件，这是默认选项 -c：使用控制台，这也是默认选项 -w：使用窗口，无控制台 使用-F的好处是会将所有的依赖文件打包到exe里，使用起来比较方便，只要给最终的exe文件就可以了。但是相应的坏处就是文件会比较大，比较慢。而-D的话生成之后需要依赖文件夹里的其他文件，需要传输所有的文件给别人才能使用，只有一个exe文件的话就会无法运行。 程序运行完成后的文件夹会多出三个文件夹![](/upload_image/blog 2004/3.png)在dist文件夹里就可以找到打包完的程序了![](/upload_image/blog 2004/4.png)其他两个文件夹为过程文件，可以不用管它了 这样我们就大功告成了！ 最新文章更新在我的博客：http://smilecoc.vip/2020/03/07/%E4%BD%BF%E7%94%A8Python%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEApi%E8%8E%B7%E5%8F%96%E4%B8%A4%E5%9C%B0%E8%B7%9D%E7%A6%BB/源码及使用的数据文件地址：https://github.com/smilecoc/baidumapapi_getdistance","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"python其他","slug":"python其他","permalink":"http://smilecoc.vip/tags/python其他/"}],"author":"smilecoc"},{"title":"在VBA中使用SQL","slug":"VBA中使用SQL","date":"2020-03-03T14:24:01.000Z","updated":"2020-07-20T15:36:12.700Z","comments":true,"path":"2020/03/03/VBA中使用SQL/","link":"","permalink":"http://smilecoc.vip/2020/03/03/VBA中使用SQL/","excerpt":"","text":"VBA在处理大量的数据/计算时如果使用常规方法会比较慢，因此需要对其进行性能优化以提高运行速度，一般的方法是数组计算或者sql计算。SQL计算的速度最快，限制也是最多的，数组速度其次，灵活性也更高 如果要在vba中调用sql处理数据基本可以遵循一个套路，只要修改其中的SQL语句即可 调用sql处理数据VBA代码如下，其中’##### #####中的地方是每次运行时要根据情况修改的： Sub Sql_Query() Dim Conn As Object, Rst As Object Dim strConn As String, strSQL As String Dim i As Integer, PathStr As String Set Conn = CreateObject(&quot;ADODB.Connection&quot;) Set Rst = CreateObject(&quot;ADODB.Recordset&quot;) PathStr = ThisWorkbook.FullName &#39;设置工作簿的完整路径和名称 Select Case Application.Version * 1 &#39;设置连接字符串,根据版本创建连接(不同版本的excel连接是不同的) Case Is &lt;= 11 strConn = &quot;Provider=Microsoft.Jet.Oledb.4.0;Extended Properties=excel 8.0;Data source=&quot; &amp; PathStr Case Is &gt;= 12 strConn = &quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&quot; &amp; PathStr &amp; &quot;;Extended Properties=&quot;&quot;Excel 12.0;HDR=YES&quot;&quot;;&quot;&quot;&quot; End Select strSQL = &quot;Select * FROM [rawdata$]&quot; &#39;####在这里改SQL查询语句#### Conn.Open strConn &#39;打开数据库链接 Set Rst = Conn.Execute(strSQL) &#39;执行查询，并将结果输出到记录集对象 With ThisWorkbook.Sheets(&quot;sql data&quot;) &#39;#####在这里更改输出的位置对应的表名#### .Cells.Clear For i = 0 To Rst.Fields.Count - 1 &#39;填写标题 .Cells(1, i + 1) = Rst.Fields(i).Name &#39;在第一行输出字段名 Next i .Range(&quot;A2&quot;).CopyFromRecordset Rst &#39;从A2单元格开始输出 .Cells.EntireColumn.AutoFit &#39;自动调整列宽 End With Rst.Close &#39;关闭数据库连接 Conn.Close Set Conn = Nothing Set Rst = Nothing End Sub 接下来，开始学习SQL语句语法 1.基于一张工作表的查询语法格式： select [DISTINCT] [TOP&lt;数值&gt; [PERCENT] &lt;列标题&gt; [[as]] &lt;别名列标题&gt;] from &lt;表或查询1&gt;[AS]&lt;别名1&gt;],&lt;表或查询2&gt;[AS]&lt;别名2&gt;],[where&lt;筛选条件&gt;][order by&lt;排序项&gt;[asc ▏ desc]] 说明： 1、&lt;&gt;表示必选项，”[]”表示可选项，”▏”表示多选一。 2、DISTINCT:消除取重复的行 3、TOP 数值：显示前几条记录 4、TOP 数值 percent：显示前面分之多少条记录 5、&lt;列标题&gt;[[as]]&lt;别名列标题&gt;:给标题列重新命一个新名称 6、where&lt;筛选条件&gt;：条件语句 7、排序，如果要按两个或两个以上字段，那么字段与字段之间用豆号隔开，asc升序，为默认值，desc降序。 select关键字如果要显示显示所有字段的记录的语法结构如下： SELECT 列字段名1,列字段名2,列字段名3 FROM [工作表名称$]select * from [sheet1$] --或者 select ID,name,address,score from [sheet1$] 语句1中的*号是代表全部列，语句 2中，是写上全部列字段的名称,如果工作表没有列标题，用F1,F2,F3,F4…..这样代替 As关键字使用别名 SELECT 姓名 AS Name FROM [Sheet1$] 注意事项：1.在SQL语句中SQL语句英文不区分大小写，但标点符号必须是英文半角状态下输入，字段名也必须跟原来的一样。2.使用SQL语句的时候，必须避免列字段中使用下面的特殊字符：空格、双引号（”）、撇（’）、数字标记（#）、百分号(%)、大于号（&gt;）、小于号(&lt;)、叹号(!)、句号(.)、方括号（[或]）、星号（*）、美元符号($)、分号（;）、脱字号（^）、圆括号（（或））、加号（+）、反斜杠（\\或/）。如果在源数据表的列字段使用了这些特殊字符，那么在使用SQL语句列出各字段的数据时，就会发生错误。为了规范使用SQL语句，在对数据源字段命名时，尽量避免使用这些特殊字符。 distinct关键字功能是去重复值只保留一条记录。语法结构为： SELECT DISTINCT 要去重复值的字段1,要去重复值的字段2 FROM [工作表名$]Select Distinct name,ID From [sheet1$] where关键字按条件筛选 使用SQL关键词 WHERE查询中的条件指定要满足什么标准信息，去掉不满足条件的数据（删除用户不要的数据）。WHERE语句中可以有多个条件，条件之间可以用操作符AND 或者OR进行连接。WHERE语句的语法结构如下： SELECT 列字段名称 FROM [表名称$] WHERE 列字段名 运算符 值运算符包含大于、小于、等于、不等于、大于或等于、小于或等于、IN、 BETWEEN、AND等。 SELECT * FROM [Sheet1$] where 消费金额=100 --提取消费金额等于100的数据 order by关键字ORDER BY的语句使用对于ORDER BY 语句而言，默认值是升序排列，通常是不指定它。但升序的关键词为ASC,降序为DESC。语法结构如下： SELECT 列字段名 FROM [工作表名称$] ORDER BY 指定列字段名 升序(降序)按成绩进行升序排序的SQL语句如下： Select * FROM [Sheet1$] ORDER BY 成绩 ASC Top关键字TOP按顺序提取前n行的记录,语法结构如下： SELECT TOP 3 * FROM [工作表名$]如提取成绩前三名的记录 Select top 3 * FROM [Sheet1$A1:C17] ORDER BY score 其中 [Sheet1$A1:C17]这个表示工作表名Sheet1的工作表A1：C17的这个单元格区域，加上了指定的单元格区域为数据。可以根据自己的实际情况，来改变.不在同一张表上显示结果，而且数据源规范，就可以直接用[工作表名$]。或者书写的时候写上列名不用星号（”*”）这两个也是和标准sql之间差别较大的地方 TOP 与 PERCENT 组合在SQL语句中的使用可以按照百分比提取数据,例如按成绩降序排列提取前30% Select TOP 30 PERCENT * FROM [Sheet1$A1:C17] ORDER BY 成绩 DESC 聚合函数SQL聚合函数包括sum,count,avg,max,min等，与excel的公式有同样的效果，但是在大数据量的情况下速度会提升很多，而且在多条件求和时会比使用sumifs简单，直观的多多条件求和的语法结构为： SELECT 分类字段1, 分类字段2 , SUM(统计字段) as 产品总数 From [Sheet1$] GROUP BY 分类字段1, 分类字段2例如按照日期和姓名汇总产品数： SELECT 日期, 姓名, SUM(产品数) as 产品总数 From [Sheet1$] GROUP BY 日期, 姓名 日期数据在SQL表达式中的应用在SQL表达式运算符条件中，要查询日期和时间类型的数据，需要在数据值两端加上井字符号（#）以表示日期类型。日期可以有多种表示方式，最符合中国人的习惯是“年-月-日”或“年/月/日”的表示方式。也就是说年月日之间的分隔符可以用“-”或“/”。例如表示2013年10月1日可以采用以下表达式：年月日 #2013-10-1#年日月 #2013-1-10#年月日 #2013/10/1#日月年 #1/10/2013/#月日年 #10/1/2013#以表达式在系统无错识别最高的应该是月/日/年 #10/1/2013# 如何查询二个日期间的数据Where …. AND…语句，例如查找大于等于2013年10月1日，小于等于2013年10月7日的数据，的SQL表达式为： SELECT * From [Sheet1$A:C] where 日期&gt;=#10/1/2013# And 日期&lt;=#10/7/2013# 还可以以单元为动态引用查询两个日期内的数据,如下图所示 strSQL = &quot;SELECT * From [Sheet1$A:C] where 日期&gt;=#&quot; &amp; Range(&quot;J1&quot;) &amp; &quot;# And 日期&lt;=#&quot; &amp; Range(&quot;K1&quot;) &amp; &quot;#&quot; ![](/upload_image/blog 2003/4.png) like关键字Like 操作符用于在 WHERE 子句中搜索列中的模糊匹配 Select 列字段名 From [工作表名$] Where 列字段 Like &#39;关键字&#39;可以加上通配符% （相当于函数公式中的通配符*） strSQL = &quot;Select * from [Sheet1$] Where 姓名 like &#39;[AB]%&#39;&quot;这一语句表示匹配姓名以A开头或B开头的数据同样的可以反向查询姓名不以A开头或B开头的数据 strSQL = &quot;Select * from [Sheet1$] Where 姓名 like &#39;[!AB]%&#39;&quot; --or strSQL = &quot;Select * from [Sheet1$] Where not 姓名 like &#39;[AB]%&#39;&quot;in关键字In运算符允许 在 WHERE 子句中规定多个值,语法如下： Select 字段 From [表名$] Where 字段 In(条件1, 条件2,条件3, ....)如果在In的条件中不是数值类型，一定要加上引号。eg: Select * FROM [Sheet1$A:D] where 省份 in(&#39;广东&#39;,&#39;广西&#39;)2.两表的上下拼接将两表连接起来的语句一般是UNION和UNION ALLUNION ALL是查询所有记录（直接连接，可以重复），UNION只查询不重复（指整条记录不重复，取唯一）的记录，两种语句如果有重复记录，则查询结果就不一样。在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。UNION在运行时先取出几个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。例如将sheet1与sheet2中的数据连接起来： SELECT 日期,姓名,产品数 From [Sheet1$] UNION SELECT 日期,姓名,产品数 From [Sheet2$] 这个是在两张表的格式一样的情况下直接连接，但是有些情况下两表的格式并不一样，这个时候可以使用下列语句：例如sheet1中有日期，姓名两个字段，而sheet2中有姓名，产品数两个字段，需要上下连接两个表格： SELECT 日期,姓名,null as 产品数 From [Sheet1$] UNION SELECT null as 日期,姓名,产品数 From [Sheet2$] 即使用null加列拼成格式相同的两个表格再连接 3.两表的左右拼接两表的左右拼接即是join关键字SQL代替Vlookup 精确查找（左连接 “Left Outer JOIN” 用法），语法结构为： Select 表名 .字段1,表名 .字段2,表名 .字段3,表名 .字段4 FROM 查询表 AS 别名1 Left Outer JOIN 被查询表 AS 别名2 ON 别名1.字段名=别名2.字段名例如： SELECT A.姓名,B.性别,B.部门 FROM [Sheet2$] AS A Left Outer JOIN [Sheet1$] AS B ON A.姓名=B.姓名 --简写为 SELECT A.姓名,性别,部门 FROM [Sheet2$]A Left JOIN [Sheet1$]B ON A.姓名=B.姓名 join除了left join外还有right join，inner join等，之间的区别与sql语句都是一致的。注意VBA中的SQL是不支持outer join连接的 4.三表连接注意语句中的括号，在VBA SQL中不使用括号会导致错误 select b.Impression,b.Click,c.Visits,c.DemandClick,c.Bounce_Rate,c.PD_Page_View,c.Add_to_Cart,c.Cart_Additions,c.My_Account_Registration,c.Average_Time_Spent,c.Checkout_Starts,c.Total_Orders from ([database template$] as a left JOIN [Raw$] as b on b.SPID=a.placement_id) left JOIN [Raw_Om$] as c on c.key=a.key&quot; 3.数据透视表TRANSFORM语句可以实现像透视表一样的显示结果，语法结构为： TRANSFORM 汇总方式 SELECT 行标签 from 表名 group by 行字段 PIVOT 列标签这一语句是非常常用的方法，要注意TRANSFORM后的汇总方式为一个聚合函数(一般为sum),同时后续的SELECT语句中不要加入a字段/b字段或者having语句，否则会导致语句错误无法运行eg: TRANSFORM Sum(数量) Select 产品名称 from [Sheet1$] group by 产品名称 PIVOT 款号TRANSFORM语句话还可以加入一些自定义的设置： TRANSFORM 汇总方式 SELECT 行标签 from 表名 group by 行字段 PIVOT 列标签 in [列标签值1，列标签值2，列标签值3.....]使用in可以限制列标签的内容，同时可以规定列字段值的展示顺序 4.一些其他SQL语句的补充在SQL中使用广泛的case关键字在VBA SQL中的实现方式为IIF，IIF的语法为：IIf(Logical EXPression, Numeric Expression1, Numeric Expression2)如果 Logical Expression 取值为 TRUE，则此函数返回 Numeric Expression1，否则，返回 Numeric Expression2。 例如：当site列填NA时，将if_address设为N，否则设为Y select name,iif([site]=&#39;NA&#39;,&#39;N&#39;,&#39;Y&#39;) as if_address form [student$]同理，Logical Expression可以使用isnull,数字等值判断语句等 同时iif语句对符合条件的数据进行计算。例如如果是赠送的，实际的花费为0,否则为原价购买计算花费 select 客户,sum(iif(buying_type=&#39;赠送&#39;,price,0)) as cost from [order$]","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"Excel & VBA","slug":"Excel-VBA","permalink":"http://smilecoc.vip/tags/Excel-VBA/"}],"author":"smilecoc"},{"title":"京东商品评论爬虫","slug":"京东商品评论爬虫","date":"2020-03-02T14:16:24.000Z","updated":"2020-07-08T16:39:23.444Z","comments":true,"path":"2020/03/02/京东商品评论爬虫/","link":"","permalink":"http://smilecoc.vip/2020/03/02/京东商品评论爬虫/","excerpt":"","text":"首先打开京东的任意几个商品页面，并观URL，可以发现都是https://item.jd.com/+数字+.htm的格式，而且数字也随着商品的改变而改变，基本上可以确定这串数字是商品ID![](/upload_image/blog 2003/1.png) 之后我们找到网页的源码并随便复制一句评论，在网页源码中查找，发现并没有找到评论内容，说明jd的评论页面并非静态网页 AJAX：AJAX的全称是Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。ajax不是新的编程语言，而是一种使用现有标准的新方法。ajax是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换。ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用ajax）如果需要更新内容，必须重载整个网页面。 既然确定是AJAX的方式加载，我们可以直接打开chrome的调试工具，在network中的XHR和JS中寻找保存有评论的文件。注意这里必须先下拉到评论页面使数据文件加载下来，否则会找不到加载的数据文件 我们可以通过两种方式来查找包含评论的文件：１.可以在ｊｓ和ＸＨＲ中寻找ｃｏｍｍｅｎｔ关键字，查看是否有文件符合要求，并对符合要求的结果筛选２.评论在页面的最下方，根据文件的加载顺序可以大致了解到会在后面，从后面开始找即可 最终确定ｊｓ文件，如下图所示![](/upload_image/blog 2003/2.png)这样我们就可以确定评论的请求地址并开始抓取 import requests import json url=&#39;https://item.jd.com/52297931949.html&#39; jsonurl=&#39;https://club.jd.com/comment/productPageComments.action?productId=52297931949&amp;score=0&amp;sortType=5&amp;page=0&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1&#39; html=requests.get(jsonurl).text #print(html) josntext=json.loads(html) comments= josntext[&#39;comments&#39;] for comment in comments: content = comment[&#39;content&#39;] print(content) 这里需要注意一下原始的jsonurl得到的文件并不是标准的json文件格式，我们可以将得到的文本内容复制到https://www.json.cn发现这并不是一个标准的josn文件，所以直接loads()会直接报错：json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)，只要返回的对象不是josn对象就会出现此错误解决的方法有两个，一是将URL中的?callback=fetchJSON_comment98去除，另外一种方法是将返回的文本对象中的fetchJSON_comment98替换为空 得到所需要的json文件后就可以将数据存到sqllite中了sqllite是python内置的关系型数据库，具有以下优点： 不需要一个单独的服务器进程或操作的系统（无服务器的）。 SQLite不需要配置，这意味着不需要安装或管理。 一个完整的SQLite数据库是存储在一个单一的跨平台的磁盘文件。 SQLite是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。 SQLite是自给自足的，这意味着不需要任何外部的依赖。 SQLite事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。 SQLite支持 SQL92（SQL2）标准的大多数查询语言的功能。 SQLite使用 ANSI-C 编写的，并提供了简单和易于使用的 API。 SQLite 在 UNIX（Linux, Mac OS-X, Android,iOS）和 Windows（Win32, WinCE,WinRT）中运行。 python操作SQLite流程与连接其他的数据库相同，大概分为以下五步 通过sqlite3.open()创建与数据库文件的连接对象connection； 通过connection.cursor()创建光标对象cursor； 通过cursor.execute()执行SQL语句； 通过connection.commit()提交当前的事务，或者通过cursor.fetchall()获得查询结果； 通过connection.close()关闭与数据库文件的连接 这一部分代码如下所示 conn=sqlite3.connect(&quot;comments.db&quot;)#建立连接，数据库存在时，直接连接；不存在时，创建相应数据库 #新建一张表 conn.execute(&#39;&#39;&#39;CREATE TABLE Comments_jd (ID text PRIMARY KEY NOT NULL, comment text );&#39;&#39;&#39;) #注意sql语句中使用了格式化输出的占位符%s和%d来表示将要插入的变量，其中%s需要加引号&#39;&#39; for comment in comments: sql = &quot;insert into Comments_jd(ID,comment) values(&#39;%s&#39;,&#39;%s&#39;)&quot; % (comment[&#39;id&#39;],comment[&#39;content&#39;]) conn.execute(sql)conn.commit() # 关闭数据库连接 conn.close() 之后检查以下数据是否有问题： conn=sqlite3.connect(&quot;comments.db&quot;) cursor = conn.execute(&quot;select * from Comments_jd&quot;) for row in cursor: print(&#39;ID = &#39;, row[0], &#39; Comment = &#39;, row[1]) conn.close() 得到的结果如下图所示![](/upload_image/blog 2003/3.png) 这样整个流程就搞定了 最终的代码如下： import requests import json import sqlite3 def get_comments(good_id): #good_url_template = &#39;https://item.jd.com/{}.html&#39;.format(good_id) jsonurl=&#39;https://club.jd.com/comment/productPageComments.action?productId={}&amp;score=0&amp;sortType=5&amp;page=0&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1&#39;.format(good_id) html=requests.get(jsonurl).text return html def data_stored(html): conn = sqlite3.connect(&quot;comments.db&quot;) # 建立连接，数据库存在时，直接连接；不存在时，创建相应数据库 # 新建一张表 conn.execute(&#39;&#39;&#39;CREATE TABLE Comments_jd (ID text PRIMARY KEY NOT NULL, comment text );&#39;&#39;&#39;) josntext=json.loads(html) comments= josntext[&#39;comments&#39;] #注意sql语句中使用了格式化输出的占位符%s和%d来表示将要插入的变量，其中%s需要加引号&#39;&#39; for comment in comments: sql = &quot;insert into Comments_jd(ID,comment) values(&#39;%s&#39;,&#39;%s&#39;)&quot; % (comment[&#39;id&#39;],comment[&#39;content&#39;]) conn.execute(sql) conn.commit() # 关闭数据库连接 conn.close() if __name__ == &#39;__main__&#39;: html=get_comments(str(52297931949)) data_stored(html)","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://smilecoc.vip/tags/python爬虫/"}],"author":"smilecoc"},{"title":"Chrome插件资源","slug":"Chrome插件资源","date":"2020-02-24T13:57:00.000Z","updated":"2020-04-12T15:40:47.732Z","comments":true,"path":"2020/02/24/Chrome插件资源/","link":"","permalink":"http://smilecoc.vip/2020/02/24/Chrome插件资源/","excerpt":"","text":"Chrome浏览器的灵魂是插件，以下是目前体验效果较好的插件推荐： adblock这个插件应该有很多人使用，它可以屏蔽网页上的广告，获得极佳的体验，神器！ tampermonkey油猴，通过油猴可以下载海量的脚本实现各种骚操作，比如在线下载，免费观看会员电影等，神器！ Sourcegraph安装插件后可以直接在github上查看代码，定位和搜索代码，不需要一个一个下载再本地打开，而且支持各种语言的IDE markdown-here可以在md语法与文本之间相互转换，例如吧在简书中的文章可以一键转化为微信的文章格式，非常方便 SimilarWeb可以在线分析网站的访问量，排行，以及访问此网站的用户分析，同时还可以直接生成网站的分析报告 Sync sofa实现两台电脑同步在浏览器里同步看片，情侣异地看片不是梦！ Chrome插件英雄榜github的项目上选出来的比较好的chrome插件，主要有:1、markdown-here可以在网页版QQ邮箱、Gmail、163等邮箱里面，使用mardown格式进行书写，然后一键转换为富文本。2、chrono可以非常方便的嗅探识别网页中的资源, 然后一键下载所有资源。3、Secure Shell AppWindows并没有自带ssh软件，有了Secure Shell App，可以让你无需下载putty或xshell，就能在chrome直接实现ssh登录服务器了。4、Tampermonkey可以帮你安装脚本，从而免费查看VIP视频，清除各种网页广告，在豆瓣影评页面显示电影资源的下载地址。5、Video Speed Controller刷一些没营养视频的时候，而网站的在线播放器一般只提供不高于4倍的播放速度,，而Video Speed Controller可以将视频播放速度提高到16倍速。 6、SimilarSites当你浏览一个很棒的站点的时候，或许你会想到，和它“差不多”的站点有哪些。尤其是针对一些资源站点，这个站点没有，而它同类的站点“往往有”。SimilarSites的作用只有一个，发现同类站点。7、Loom可以一键录制浏览器的单个标签页，录制完成后自动生成在线网页，进行视频播放，可以下载刚刚录制的视频，也可以为刚刚生成的在线视频设置密码。8、Chrome Cleaner ProChrome经过最近几年的发展，强力的扩展越来越多，但软件会变慢。让Chrome变快的最简单方式就是清理垃圾，而Chrome Cleaner Pro走的是一键清理的路子。9、vimium可以让你只使用键盘就可以浏览网页。10、speedtest在浏览器中直接测网速。11、whatruns如果你对当前浏览的网站非常感兴趣, 可以通过whatruns了解软件的技术栈。12、OurStickys可以直接在网站上贴便签。 13、Quick QR可以不借助任何通讯软件，通过手机扫码，获取PC浏览器上任意一段文字信息。14、超级马里奥游戏用Chrome玩超级马里奥。15、XPath HelperXPath是一个辅助写爬虫的小插件，比如可以帮助完成一个Bing壁纸的小爬虫。16、解除B站区域限制如题。17、新浪微博图床用Markdown写文章，如果文章中使用了本地配图，那本地配图就要和文章一起打包，否则别人看不到图片。新浪微博图床帮你把本地图片放到网络服务器，然后直接把图片的url粘贴到文章里面，就可以免除图片打包的步骤。18、Enhanced Github可以显示GitHub整个仓库和单个文件的大小，帮你下载Github优秀项目中最核心的代码文件进行学习，而不是下载整个仓库作为藏品。 19、MEGA一个网盘应用，没有限速的概念，在国内可用，云端加密，官方提供了Linux客户端。20、Boxel ReboundChrome中的跑酷游戏。可以自由创建赛道，分享赛道,，获取别人的赛道进行二次开发。21、哔哩哔哩助手具备纯净看视频，下载视频&amp;弹幕等实用功能。22、扩展管理器管理你的Chrome扩展。23、FireShot一键滚动截屏整个网页。24、Dark Reader为任意网站启用夜间模式。 25、ConsoleChrome自带的计算器，可以看到加数字的记录，也可以实时预览运算的结果。26、Quickey Launcher为任意网页绑定一个快捷键，绑定完成后可通过快捷键打开网页。27、Text由谷歌Chrome实验室研发并开源的跨平台记事本。28、Adblock浏览网页时，可以使用右键工具屏蔽不喜欢的广告。 29、SimpRead为任意网页开启阅读模式。30、掘金阅读插件，提供程序员、设计师等行业知识。31、OneTab把所有打开的标签页转换成一个列表，需要再次访问标签页时，点击列表恢复标签页。32、Smallpdf多份pdf在线合并，pdf在线编辑。33、一叶在任意网页开启实时弹幕、聊天窗口和留言板。34、Astro Bot刷题必备，打开新标签页时，展示一道与程序相关的问题或相关新闻。 35、Print Friendly &amp; PDF文件打印的chrome插件，会在打印之前删除垃圾广告，导航和无用浮窗来实现页面优化。36、Screen Shader把屏幕调成暖色。37、Saladict查单词的时候，聚合多个词典的结果，并行翻译。38、Alexa Traffic Rank一键查看网站全球排名。39、Simplify Gmail让网页版Gmail更清爽。40、GitZip for github从Github批量下载表情包。 41、Copy All Urls方便地保存-开启多个标签页。42、在Edge中安装Chrome扩展程序如题。43、Dream Afar New Tab设置更加唯美的Chrome背景。44、谷歌访问助手如题，但限制条件一箩筐。45、Restlet Client开发实用工具, 支持一键导入Postman等API测试工具的测试用例。46、WhatFont功能非常单一的小工具，帮你查看网页上的字体属性。47、Go to Tab形成一个下拉列表，帮你快速跳转到打开的网页48、Words Discoverer突出显示网页上罕见的英语字典词汇和惯用语。 49、Web Server for Chrome可以在本地快速开启http服务，让开发和测试变得更加简单。也可以和局域网的小伙伴建立一个共享文件夹。50、Google Results Previewer不用点链接就能看谷歌搜索结果。51、Custom Cursor for Chrome™在Chrome中设置鼠标的形式，比如可以换成初音未来等，让你回归QQ空间时代。 52、Site Palette自动提取网站配色。53、鼠标点击特效 (๑•́ ∀ •̀๑)为鼠标点击添加有趣的特效的扩展程序。54、二箱 以图搜图如题。55、Keylines为网页元素添加随机描边颜色。56、Search为Chrome设置搜索引擎关键词，快速在Chrome里面进行搜索。 57、网页图片另存为JPG/PNG/WebP让WebP图片下载为PNG格式。58、IP-Address快速查看当前设备IP。59、PageSpeed Insight and CheckList为网页优化提供建议和量化指标60、Tabagotchi以一种有趣的方式，提醒我们减少标签页数量，减少计算机产生的热量，为阻止全球变暖做出了贡献。 传送门：https://github.com/zhaoolee/ChromeAppHeroes 安装插件的方法1.谷歌商店直接下载安装（需要梯子)2.下载插件文件，然后你只要在 Chrome 中输入chrome://extensions/，接着把插件拖进去安装就可以了","categories":[{"name":"资源","slug":"资源","permalink":"http://smilecoc.vip/categories/资源/"}],"tags":[{"name":"其他资源","slug":"其他资源","permalink":"http://smilecoc.vip/tags/其他资源/"}],"author":"smilecoc"},{"title":"B站每日排行榜爬虫","slug":"B站每日排行榜爬虫","date":"2020-02-15T07:59:01.000Z","updated":"2020-02-26T14:30:21.718Z","comments":true,"path":"2020/02/15/B站每日排行榜爬虫/","link":"","permalink":"http://smilecoc.vip/2020/02/15/B站每日排行榜爬虫/","excerpt":"","text":"爬取B站排行榜前100名的视频名称，作者和播放量，用到的主要有request库获取网页信息，用正则解析网页并使用openpyxl将信息保存在Excel中 第一部分为请求网页获取信息部分，request库的基本用法 def get_html_text(url,self_header): try: response = requests.get(url,headers=self_header,timeout=30) response.raise_for_status() response.encoding = response.apparent_encoding #print(response.text) return response.text except: return &quot;&quot; 第二部分为用正则表达式解析网页内容并保存到Excel def re_get_inf(html): list=[] rank_list=re.findall(r&#39;&lt;div class=&quot;num&quot;&gt;(\\d*)&lt;/div&gt;&#39;,html)#排名 title_list=re.findall(r&#39;&lt;div class=&quot;info&quot;&gt;&lt;a href=[\\s\\S]*?class=&quot;title&quot;&gt;([\\s\\S]*?)&lt;/a&gt;&lt;!----&gt;&#39;,html)#视频名称 play_num=re.findall(r&#39;&lt;div class=&quot;detail&quot;&gt;&lt;span class=&quot;data-box&quot;&gt;&lt;i class=&quot;b-icon play&quot;&gt;&lt;/i&gt;(\\d*.\\d*)\\S&lt;/span&gt;&#39;,html)#播放量 author_list=re.findall(r&#39;&lt;span class=&quot;data-box&quot;&gt;&lt;i class=&quot;b-icon author&quot;&gt;&lt;/i&gt;([\\s\\S]*?)&lt;/span&gt;&#39;,html)#UP主名称 wb=Workbook()#新建保存文件 sheet=wb.active sheet.append([&#39;rank&#39;,&#39;title&#39;,&#39;playnum&#39;,&#39;author&#39;])#写入标题名称 for i in range(len(rank_list)): rank = rank_list[i] title = title_list[i] playnum=play_num[i] author=author_list[i] sheet.append([rank,title,playnum,author])#写入数据 wb.save(&#39;bilibili_rankdata.xlsx&#39;)#保存文件 完整代码如下所示，代码与结果文件链接可以点击以下链接： https://github.com/smilecoc/bilibili_rankdata #Bilibili每日热榜爬虫 import re import requests from openpyxl import Workbook def get_html_text(url,self_header): try: response = requests.get(url,headers=self_header,timeout=30) response.raise_for_status() response.encoding = response.apparent_encoding #print(response.text) return response.text except: return &quot;&quot; def re_get_inf(html): list=[] rank_list=re.findall(r&#39;&lt;div class=&quot;num&quot;&gt;(\\d*)&lt;/div&gt;&#39;,html) title_list=re.findall(r&#39;&lt;div class=&quot;info&quot;&gt;&lt;a href=[\\s\\S]*?class=&quot;title&quot;&gt;([\\s\\S]*?)&lt;/a&gt;&lt;!----&gt;&#39;,html) play_num=re.findall(r&#39;&lt;div class=&quot;detail&quot;&gt;&lt;span class=&quot;data-box&quot;&gt;&lt;i class=&quot;b-icon play&quot;&gt;&lt;/i&gt;(\\d*.\\d*)\\S&lt;/span&gt;&#39;,html) author_list=re.findall(r&#39;&lt;span class=&quot;data-box&quot;&gt;&lt;i class=&quot;b-icon author&quot;&gt;&lt;/i&gt;([\\s\\S]*?)&lt;/span&gt;&#39;,html) wb=Workbook() sheet=wb.active sheet.append([&#39;rank&#39;,&#39;title&#39;,&#39;playnum&#39;,&#39;author&#39;]) for i in range(len(rank_list)): rank = rank_list[i] title = title_list[i] playnum=play_num[i] author=author_list[i] sheet.append([rank,title,playnum,author]) wb.save(&#39;bilibili_rankdata.xlsx&#39;) def main(): bilibili_url=&#39;https://www.bilibili.com/ranking/all/0/0/3&#39; self_header = { &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot; } html=get_html_text(bilibili_url,self_header) re_get_inf(html) if __name__ == &#39;__main__&#39;: main()","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://smilecoc.vip/tags/python爬虫/"}],"author":"smilecoc"},{"title":"Hexo Sakura主题的问题汇总","slug":"Hexo Sakura主题遇到的问题汇总","date":"2020-02-02T14:02:02.000Z","updated":"2020-07-08T16:49:13.205Z","comments":true,"path":"2020/02/02/Hexo Sakura主题遇到的问题汇总/","link":"","permalink":"http://smilecoc.vip/2020/02/02/Hexo Sakura主题遇到的问题汇总/","excerpt":"","text":"代码高亮刚用的时候代码框十分诡异而且压根就没有高亮。找了几种方法并不可行，整理了一下几种可能错误的原因。错误可能为1.markdown(md)语法问题，将代码块改为如下格式： ```+语言名（比如java）代码内容``` 2.与hexo自带的高亮冲突了，只要把站点配置文件中： highlight: enable: true true改为false就可以了。注意是站点配置文件而不是主题配置文件 搜索搜索一直不能用的原因就是少了个插件。 git bash中执行： npm install hexo-generator-json-content --save 文章内插入图片在文章中写入: ![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 赞赏页面的作者名称修改赞赏页面的页脚作者永远是原作者的名称，可能是没有链接到变量的bug吧 修改方法为将”\\blog\\themes\\Sakura\\themes\\Sakura\\layout\\donate.ejs”中的 &lt;h3 itemprop=&quot;name&quot;&gt; &lt;a href=&quot;&lt;%- theme.url%&gt;&quot; itemprop=&quot;url&quot; rel=&quot;author&quot;&gt;houjun&lt;/a&gt; &lt;/h3&gt; “houjun”换为自己的名字就可以了 另外其他的相似问题比如友链页面的描述需要改动的话也是一样的方法 主题工具在themes\\sakura\\layout\\layout.ejs中： &lt;div class=&quot;scrollbar&quot; id=&quot;bar&quot;&gt; &lt;/div&gt; 前面添加： &lt;%- partial(&#39;_partial/setdisplay&#39;) %&gt; &lt;%- partial(&#39;_partial/set&#39;, null, {cache: !config.relative_link}) %&gt; 原版是在&lt;%- partial(‘_partial/mheader’, null, {cache: !config.relative_link}) %&gt;前添加的，但要这样字体切换会出bug。 在\\themes\\sakura\\layout_partial中新建set.ejs，内容： &lt;div class=&quot;changeSkin-gear no-select&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;span id=&quot;open-skinMenu&quot;&gt; SCHEME TOOL | 主题工具 &amp;nbsp; &lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt; &lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 新建setdisplay.ejs，内容： &lt;div class=&quot;skin-menu no-select&quot; id=&quot;mainskin&quot; style=&quot;position: fixed&quot;&gt; &lt;div class=&quot;theme-controls row-container&quot;&gt; &lt;p style=&quot;text-align:center;font-family:&#39;Monaco&#39;;font-weight:bold;color:#444&quot;&gt;&lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; background &lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/p&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li id=&quot;white-bg&quot;&gt; &lt;i class=&quot;fa fa-television&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;sakura-bg&quot;&gt; &lt;i class=&quot;iconfont icon-sakura&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;gribs-bg&quot;&gt; &lt;i class=&quot;fa fa-slack&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;KAdots-bg&quot;&gt; &lt;i class=&quot;iconfont icon-dots&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;totem-bg&quot;&gt; &lt;i class=&quot;fa fa-optin-monster&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;pixiv-bg&quot;&gt; &lt;i class=&quot;iconfont icon-pixiv&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;bing-bg&quot;&gt; &lt;i class=&quot;iconfont icon-bing&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;dark-bg&quot;&gt; &lt;i class=&quot;fa fa-moon-o&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;canvas id=&quot;night-mode-cover&quot;&gt; &lt;/canvas&gt; &lt;/div&gt; 还要修点bug： 在\\themes\\sakura\\source\\js\\sakura-app.js中，找到函数$(‘.skin-menu #dark-bg’).click(function ()，函数最底下添加： setCookie(&#39;bgImgSetting&#39;,&#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/starry_sky.png&#39;,30)把所有形如： $(&#39;.changeSkin-gear, .toc&#39;).css(&#39;background&#39;, &#39;none&#39;) 或 $(&#39;.changeSkin-gear, .toc&#39;).css(&#39;background&#39;, &#39;rgba(255,255,255,0.8)&#39;) 里的.changeSkin-gear,删掉。 这只是初始版，后面还有更高级的。 更换bing图片bing主题是从bing随机图片api获取一张图片做背景，可以更换。 在\\themes\\sakura\\source\\js\\sakura-app.js中，下面两句： changeBGnoTrans(&#39;#bing-bg&#39;, &#39;https://api.shino.cc/bing/&#39;) else if (bgurl == &#39;https://api.shino.cc/bing/&#39;) 其中的网址换成其他url。 位置和外观在set.ejs里直接用css美化，可能还要修正setdisplay.ejs。 参考配置： set.ejs： &lt;div class=&quot;changeSkin-gear no-select&quot; style=&quot;background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%; visibility: visible; bottom: 0px;&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;button id=&quot;open-skinMenu&quot;&gt; &lt;style&gt; button#open-skinMenu{ transition: all 0.2s linear 0s; outline:none; position:fixed; bottom:13px; left:15px; font-size:16px; background-color: rgba(255,255,255,.95); border-radius: 20px; box-shadow: 0 3px 8px 0 rgba(0,0,0,0.1), 0 3px 8px 0 rgba(0,0,0,0.1); } button#open-skinMenu:hover{ transition: all 0.2s linear 0s; background-color: rgb(255, 165, 0); color: rgba(255,255,255); } &lt;/style&gt; &lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt; &lt;/i&gt; SCHEME TOOL | 主题工具 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 文章列表图片拉伸问题浏览某个分类或标签下的文章下时，配图是被压缩成正方形的,导致原来的图片产生变形解决办法为：在\\themes\\sakura\\source\\css\\style.css中，找到.feature img，内部添加： object-fit: cover; 对主题进行魔改生成网页的代码都在\\blog\\themes\\Sakura\\themes\\Sakura\\layout文件夹中，通过名称可以找到整个网页的代码，对照生成的网页源码找到对应的额文件进行修改即可。不清楚相对路径是否形同，可以多多进行尝试 后续cdn的添加和修改如果需要对cdn里的文件进行修改，例如删除和更名，改变文件结构等： 克隆Github仓库到本地点击 Clone or download，一键复制仓库地址![](/upload_image/blog 2002/1.jfif)在本地目录右键 Git Bash Here，执行以下命令： git clone 一键复制的仓库地址 上传资源复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令： git status //查看状态 git add . //添加所有文件到暂存区 git commit -m &#39;第一次提交&#39; //把文件提交到仓库 git push //推送至远程仓库 发布仓库点击release发布![](/upload_image/blog 2002/2.jfif)自定义发布版本号![](/upload_image/blog 2002/3.jfif) 通过jsDelivr引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径例如：https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.csshttps://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： // 加载任何Github发布、提交或分支 https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.2.1 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本 https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表 https://cdn.jsdelivr.net/gh/jquery/jquery/ Rss页面修改RSS配置后是404的页面，解决步骤如下：安装插件 npm install hexo-generator-feed 主配置_config.yml文末添加 # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: hexo-generator-feed #Feed Atom feed: type: atom #RSS的类型(atom/rss2) path: atom.xml #文件路径,默认是atom.xml/rss2.xml limit: 20 #展示文章的数量,使用0或则false代表展示全部 hub: content: #在RSS文件中是否包含内容 ,有3个值 true/false默认不填为false content_limit: 140 #指定内容的长度作为摘要,仅仅在上面content设置为false和没有自定义的描述出现 content_limit_delim: &#39; &#39; #上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断. order_by: -date icon: #icon.png 主题配置themes\\sakura_config.yml文末添加(sakura主题中应该已有这一句，如果已有的话可以直接跳过) # 简易信息聚合,站点共享 rss: /atom.xml 添加搜索引擎收录查看网站是否被收录首先我们可以输入 site:域名 来查看域名是否被搜索引擎收录，如果没有相关网页，表示没有收录 提交百度搜索github是禁止百度爬虫的，所以如果你是和我一样在github中建立的静态网站，想要在百度中被搜到需要将博客双线部署到国内的代码托管平台。这里使用Coding。另外百度收录的所需的时间较长，大约半个月左右才会看到效果！ 创建项目：进入 Coding 官网，点击个人版登陆，没有账号就注册一个并登录，进入后有啥提示引导的话跳过，点击创建项目。项目名称建议和你的用户名一致，这样做的好处是：到时候可以直接通过user_name.coding.me访问你的博客，如果项目名与用户名不一致，则需要通过user_name.coding.me/project_name才能访问，项目描述可以随便写 配置公钥。配置 SSH 公钥方法与 GitHub Pages 的方式差不多，点击你的头像，依次选择 个人设置-SSH公钥-新增公钥，前面部署到 GitHub Pages 的时候就已经有了一对公钥，我们直接将该公钥粘贴进去就行，公钥名称可以随便写，选中永久有效选项 PS：公钥储存位置一般在 C:\\Users\\用户名.ssh 目录下的 id_rsa.pub 文件里，用记事本打开复制其内容即可。另外由于coding的UI变化很快，所以有些按钮的位置和层级已经变化需要找一下，但是差的不多，实在不行的话就百度 添加公钥后，我们可以右键Get Bash，输入以下命令来检查是否配置成功：ssh -T git@e.coding.net `若出现以下提示，则证明配置成功：coding 提示: Hello XXX, You&#39;ve connected to Coding.net via SSH. This is a personal key. XXX，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥 配置 _config.yml:进入你的项目，在右下角有选择连接方式，选择 SSH 方式（HTTPS 方式也可以，但是这种方式有时候可能连接不上，SSH 连接不容易出问题），一键复制，然后打开你本地博客根目录的 _config.yml 文件，找到 deploy 关键字，添加 coding 地址，也就是刚刚复制的 SSH 地址:deploy: type: git repository: github: git@github.com:xxx/xxx.github.io.git coding: git@e.coding.net:xxx/xxx/xxx.git branch: master注意中间有空格。添加完成后先执行命令 hexo clean 清理一下缓存，然后执行命令 hexo g -d 将博客双线部署到 Coding Pages 和 GitHub Pages，可以查看一下代码仓库是否有代码上传，如果有即表示部署成功： 开启 Coding Pages。打开 项目设置-项目与成员-功能开关，打开 持续集成 和 持续部署，然后在 持续部署 中可以看到静态网站。经过身份验证后即可开启 绑定域名并开启 HPPTS：首先在你的域名 DNS 设置中添加一条 CNAME 记录指向 xxxx.coding.me，解析路线选择 默认，将 GitHub 的解析路线改为 境外，这样境外访问就会走 GitHub，境内就会走 Coding，也有人说阿里云是智能解析，自动分配路线，如果解析路线都是默认，境外访问同样会智能选择走 GitHub，境内走 Coding，我没有验证过，有兴趣的可以自己试试，我的解析如下图所示：然后点击静态 Pages 应用右上角的设置，进入设置页面，这里要注意，如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL/TLS 安全证书就会显示申请错误，当你访问你的网站时，浏览器就会提示不是安全连接。申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问这里也建议同时绑定有 www 前缀和没有 www 前缀的，如果要绑定没有 www 前缀的，首先要去域名 DNS 添加一个 A 记录，主机记录为 @，记录值为你博客 IP 地址，IP 地址可以在 cmd 命令行 ping 一下得到，然后在 Coding Pages 中设置其中一个为【首选】，另一个设置【跳转至首选】，这样不管用户是否输入 www 前缀都会跳到有 www 前缀的了至此，我们的 Hexo 博客就成功双线部署到 Coding Pages 和 GitHub Pages 了。 访问百度搜索资源平台官网，注册或者登陆百度账号，依次选择 用户中心-站点管理 ，添加你的网站，在添加站点时会让你选择协议头（http 或者 https），之后会让你验证网站所有权，提供三种验证方式： 文件验证：下载给定的文件，将其放到本地主题目录 source 文件夹，然后部署上去完成验证 HTML 标签验证：一般是给一个 meta 标签，放到首页 与 标签之间即可完成验证 CNAME 验证：去域名 DNS 添加一个 CNAME 记录即可完成验证 提交百度搜索:百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和 sitemap 三种方式,推荐同时使用主动推送和 sitemap 方式 主动推送可以在博客根目录安装插件 npm install hexo-baidu-url-submit –save，然后在根目录 _config.yml 文件里写入以下配置：baidu_url_submit: count: 1 # 提交最新的多少个链接 host: www.itrhx.com # 在百度站长平台中添加的域名 token: your_token # 秘钥 path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里其中的其中的 token 可以在【链接提交】-【自动提交】-【主动推送】下面看到，接口调用地址最后面 token=xxxxx 即为你的 token同样是在根目录的 _config.yml 文件，大约第 17 行处，url 要改为在百度站长平台添加的域名，也就是你网站的首页地址：# URL url: https://www.itrhx.com root: / permalink: :year/:month/:day/:title/ 最后，加入新的 deployer： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git repository: github: git@github.com:TRHX/TRHX.github.io.git # 这是原来的 github 配置 coding: git@git.dev.tencent.com:TRHX/TRHX.git # 这是原来的 coding 配置 branch: master - type: baidu_url_submitter # 这是新加的主动推送最后执行 hexo g -d 部署一遍即可实现主动推送，推送成功的标志是：在执行部署命令最后会显示类似如下代码： {&quot;remain&quot;:4999953,&quot;success&quot;:47} INFO Deploy done: baidu_url_submitter sitemap提交：首先我们要使用以下命令生成一个网站地图： npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save这里也注意一下，将根目录的 _config.yml 文件，大约第 17 行处，url 改为在百度站长平台添加的域名，也就是你网站的首页地址： # URL url: https://www.itrhx.com root: / permalink: :year/:month/:day/:title/然后使用命令 hexo g -d 将网站部署上去，然后访问 你的首页/sitemap.xml 或者 你的首页/baidusitemap.xml 就可以看到网站地图了比如我的是：https://www.itrhx.com/baidusitemap.xml 或者 https://www.itrhx.com/sitemap.xml其中 sitemap.xml 文件是搜索引擎通用的 sitemap 文件，baidusitemap.xml 是百度专用的 sitemap 文件然后来到百度站长平台的 sitemap 提交页面，将你的 sitemap 地址提交即可，如果成功的话状态会显示为正常，初次提交要等几分钟，sitemap.xml 相比 baidusitemap.xml 来说等待时间也会更长，如果以后你博客有新的文章或其他页面，可以点击手动更新文件，更新一下新的 sitemap 提交谷歌搜索提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用site:域名查看网站是否被收录接下来我们将网站提交谷歌搜索引擎搜索，进入谷歌站长平台，登录你的谷歌账号之后会让你验证网站所有权.所有操作需要科学上网之后有两种验证方式，分别是网域和网址前缀，选择一个适合的就行。我用的是比较简单的网址前缀，根据谷歌给的提示做后续的操作就可以的。谷歌收录基本上等几分钟就可以看到结果了，非常快,而且也不需要添加sitemap或者设置自动推送就可以直接抓取到内容了，非常方便 提交必应搜索必应收录也是很简单，点击必应站长。先注册登录，必应收录有两种方式，一种使用刚刚谷歌导入过去，第二种是就是自己添加URL,跟着提示操作就行。不过必应也收录也比较慢，只比百度稍快一点 参考文章/网站：ctz’s blogyremp’s bloghttps://blog.csdn.net/qq_36759224/article/details/100879609https://www.itrhx.com/2019/09/17/A48-submit-search-engine-inclusion/","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://smilecoc.vip/tags/blog/"}],"author":"smilecoc"},{"title":"定制系统与使用方式资源","slug":"定制系统资源","date":"2019-12-31T16:00:00.000Z","updated":"2020-02-23T09:52:50.476Z","comments":true,"path":"2020/01/01/定制系统资源/","link":"","permalink":"http://smilecoc.vip/2020/01/01/定制系统资源/","excerpt":"","text":"定制系统资源下载 https://www.drblack-system.com/index.php/system/ 系统安装方法之：PE安装 https://www.drblack-system.com/index.php/2019/08/19/%e7%b3%bb%e7%bb%9f%e5%ae%89%e8%a3%85%e6%96%b9%e6%b3%95%e4%b9%8b%ef%bc%9ape%e5%ae%89%e8%a3%85/ 系统安装方法之：硬盘安装 https://www.drblack-system.com/index.php/2019/03/24/bilibili-os%e3%81%ae%e7%a1%ac%e7%9b%98%e5%ae%89%e8%a3%85%e6%96%b9%e6%b3%95/","categories":[{"name":"资源","slug":"资源","permalink":"http://smilecoc.vip/categories/资源/"}],"tags":[{"name":"其他资源","slug":"其他资源","permalink":"http://smilecoc.vip/tags/其他资源/"}],"author":"smilecoc"},{"title":"SQL实现筛选出连续3天登录用户","slug":"SQL实现筛选出连续3天登录用户","date":"2019-12-25T08:24:08.000Z","updated":"2020-07-08T16:27:26.981Z","comments":true,"path":"2019/12/25/SQL实现筛选出连续3天登录用户/","link":"","permalink":"http://smilecoc.vip/2019/12/25/SQL实现筛选出连续3天登录用户/","excerpt":"","text":"这个问题虽然说难不难，但说易也不简单，而且，偏受大小厂喜欢。其实，不管是数仓/ETL/BI/数据分析/大数据等方向，都会经常被面试/笔试考察到。 1.还原场景 - 建表select * from tmp.tmp_last_3_day;2.解决问题关键-分析解决问题的关键是：如何判断连续 可通过对user_id分组排序后（rn），用登录日期减去序号m,如果连续的话，则得到的这个日期（flag_date）会相同即： flag_date=login_date-rn对应SQL：date_sub(login_date,rn) 3.SQL实现连续3天登录的用户id ­­ sql如下： select user_id,count(1） cnt --date_sub(login_date,t.rn) flag_date from ( select user_id,login_date, row_number() over(partition by user_id order by login_date) as rn from tmp.tmp_last_3_day ) t group by user_id,date_sub(login_date,t.rn) having count(1)&gt;=3; 我们再来看下结果： 其实，方法有很多，上面只是选了一种技巧性比较强的一种。下面也是一种不错的方法。 select count(distinct b.id) as c1 from ( select id,date,lead(date,2,-1) over(partition by user_id order by date desc) as date1 from tb_use a group by id.date ) as b where date_sub(cast(b.date as date),2)=cast(b.date1 as date);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://smilecoc.vip/categories/笔记/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"简单实用的SQL脚本汇总","slug":"简单实用的SQL脚本汇总","date":"2019-09-30T16:00:01.000Z","updated":"2020-07-08T16:27:09.671Z","comments":true,"path":"2019/10/01/简单实用的SQL脚本汇总/","link":"","permalink":"http://smilecoc.vip/2019/10/01/简单实用的SQL脚本汇总/","excerpt":"","text":"1、行转列的用法PIVOTCREATE table test (id int,name nvarchar(20),quarter int,number int) insert into test values(1,N&#39;苹果&#39;,1,1000) insert into test values(1,N&#39;苹果&#39;,2,2000) insert into test values(1,N&#39;苹果&#39;,3,4000) insert into test values(1,N&#39;苹果&#39;,4,5000) insert into test values(2,N&#39;梨子&#39;,1,3000) insert into test values(2,N&#39;梨子&#39;,2,3500) insert into test values(2,N&#39;梨子&#39;,3,4200) insert into test values(2,N&#39;梨子&#39;,4,5500) select * from test 结果： select ID,NAME, [1] as &#39;一季度&#39;, [2] as &#39;二季度&#39;, [3] as &#39;三季度&#39;, [4] as &#39;四季度&#39; from test pivot ( sum(number) for quarter in ([1],[2],[3],[4]) ) as pvt 结果： 2、列转行的用法UNPIOVTcreate table test2 (id int,name varchar(20), Q1 int, Q2 int, Q3 int, Q4 int) insert into test2 values(1,&#39;苹果&#39;,1000,2000,4000,5000) insert into test2 values(2,&#39;梨子&#39;,3000,3500,4200,5500) select * from test2 结果： --列转行 select id,name,quarter,number from test2 unpivot ( number for quarter in ([Q1],[Q2],[Q3],[Q4]) ) as unpvt 结果： 3、字符串替换SUBSTRING/REPLACESELECT REPLACE(&#39;abcdefg&#39;,SUBSTRING(&#39;abcdefg&#39;,2,4),&#39;**&#39;) 结果： SELECT REPLACE(&#39;12345678@qq.com&#39;,&#39;1234567&#39;,&#39;******&#39;) 结果： 4、查询一个表内相同纪录 HAVINGHR.Employees表的表结构：如果一个ID可以区分的话，可以这么写 select * from HR.Employees where title in ( select title from HR.Employees group by title having count(1)&gt;1) 结果： 对比一下发现，ID为1,2的被过滤掉了，因为他们只有一条记录 如果有几个ID需要区分的话可以这么写 select * from HR.Employees where title+titleofcourtesy in (select title+titleofcourtesy from HR.Employees group by title,titleofcourtesy having count(1)&gt;1) 结果： title在和titleofcourtesy进行拼接后符合条件的就只有ID为6,7,8,9的了 5、把多行SQL数据变成一条多列数据，即新增列SELECT id, name, SUM(CASE WHEN quarter=1 THEN number ELSE 0 END) &#39;一季度&#39;, SUM(CASE WHEN quarter=2 THEN number ELSE 0 END) &#39;二季度&#39;, SUM(CASE WHEN quarter=3 THEN number ELSE 0 END) &#39;三季度&#39;, SUM(CASE WHEN quarter=4 THEN number ELSE 0 END) &#39;四季度&#39; FROM test GROUP BY id,name 结果： 我们将原来的4列增加到了6列。细心的朋友可能发现了这个结果和上面的行转列怎么一模一样？其实上面的行转列是省略写法，这种是比较通用的写法。 6、表复制语法1：Insert INTO table(field1,field2,…) values(value1,value2,…) 语法2：Insert into Table2(field1,field2,…) select value1,value2,… from Table1 （要求目标表Table2必须存在，由于目标表Table2已经存在，所以我们除了插入源表Table1的字段外，还可以插入常量。） 语法3：SELECT vale1, value2 into Table2 from Table1 （要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。） 语法4：使用导入导出功能进行全表复制。如果是使用【编写查询以指定要传输的数据】，那么在大数据表的复制就会有问题？因为复制到一定程度就不再动了，内存爆了？它也没有写入到表中。而使用上面3种语法直接执行是会马上刷新到数据库表中的，你刷新一下mdf文件就知道了。 7、利用带关联子查询Update语句更新数据--方法1： Update Table1 set c = (select c from Table2 where a = Table1.a) where c is null --方法2： update A set newqiantity=B.qiantity from A,B where A.bnum=B.bnum --方法3： update (select A.bnum ,A.newqiantity,B.qiantity from A left join B on A.bnum=B.bnum) AS C set C.newqiantity = C.qiantity where C.bnum =&#39;001&#39; 8、连接远程服务器--方法1： select * from openrowset( &#39;SQLOLEDB&#39;, &#39;server=192.168.0.1;uid=sa;pwd=password&#39;, &#39;SELECT * FROM dbo.test&#39;) --方法2： select * from openrowset( &#39;SQLOLEDB&#39;, &#39;192.168.0.1&#39;; &#39;sa&#39;; &#39;password&#39;, &#39;SELECT * FROM dbo.test&#39;) 当然也可以参考以前的示例，建立DBLINK进行远程连接 9、Date 和 Time 样式 CONVERTCONVERT() 函数是把日期转换为新数据类型的通用函数。CONVERT() 函数可以用不同的格式显示日期/时间数据。 语法: CONVERT(data_type(length),data_to_be_converted,style) data_type(length) 规定目标数据类型（带有可选的长度）。data_to_be_converted 含有需要转换的值。style 规定日期/时间的输出格式。 可以使用的 style 值： SELECT CONVERT(varchar(100), GETDATE(), 0) --结果： 01 2 2019 9:33PM SELECT CONVERT(varchar(100), GETDATE(), 1) --结果： 01/02/19 SELECT CONVERT(varchar(100), GETDATE(), 2) --结果： 19.01.02 SELECT CONVERT(varchar(100), GETDATE(), 3) --结果： 02/01/19 SELECT CONVERT(varchar(100), GETDATE(), 4) --结果： 02.01.19 SELECT CONVERT(varchar(100), GETDATE(), 5) --结果： 02-01-19 SELECT CONVERT(varchar(100), GETDATE(), 6) --结果： 02 01 19 SELECT CONVERT(varchar(100), GETDATE(), 7) --结果： 01 02, 19 SELECT CONVERT(varchar(100), GETDATE(), 8) --结果： 21:33:18 SELECT CONVERT(varchar(100), GETDATE(), 9) --结果： 01 2 2019 9:33:18:780PM SELECT CONVERT(varchar(100), GETDATE(), 10) --结果： 01-02-19 SELECT CONVERT(varchar(100), GETDATE(), 11) --结果： 19/01/02 SELECT CONVERT(varchar(100), GETDATE(), 12) --结果： 190102 SELECT CONVERT(varchar(100), GETDATE(), 13) --结果： 02 01 2019 21:33:18:780 SELECT CONVERT(varchar(100), GETDATE(), 14) --结果： 21:33:18:780 SELECT CONVERT(varchar(100), GETDATE(), 20) --结果： 2019-01-02 21:33:18 SELECT CONVERT(varchar(100), GETDATE(), 21) --结果： 2019-01-02 21:33:18.780 SELECT CONVERT(varchar(100), GETDATE(), 22) --结果： 01/02/19 9:33:18 PM SELECT CONVERT(varchar(100), GETDATE(), 23) --结果： 2019-01-02 SELECT CONVERT(varchar(100), GETDATE(), 24) --结果： 21:33:18 SELECT CONVERT(varchar(100), GETDATE(), 25) --结果： 2019-01-02 21:33:18.780 SELECT CONVERT(varchar(100), GETDATE(), 100) --结果： 01 2 2019 9:33PM SELECT CONVERT(varchar(100), GETDATE(), 101) --结果： 01/02/2019 SELECT CONVERT(varchar(100), GETDATE(), 102) --结果： 2019.01.02 SELECT CONVERT(varchar(100), GETDATE(), 103) --结果： 02/01/2019 SELECT CONVERT(varchar(100), GETDATE(), 104) --结果： 02.01.2019 SELECT CONVERT(varchar(100), GETDATE(), 105) --结果： 02-01-2019 SELECT CONVERT(varchar(100), GETDATE(), 106) --结果： 02 01 2019 SELECT CONVERT(varchar(100), GETDATE(), 107) --结果： 01 02, 2019 SELECT CONVERT(varchar(100), GETDATE(), 108) --结果： 21:33:18 SELECT CONVERT(varchar(100), GETDATE(), 109) --结果： 01 2 2019 9:33:18:780PM SELECT CONVERT(varchar(100), GETDATE(), 110) --结果： 01-02-2019 SELECT CONVERT(varchar(100), GETDATE(), 111) --结果： 2019/01/02 SELECT CONVERT(varchar(100), GETDATE(), 112) --结果： 20190102 SELECT CONVERT(varchar(100), GETDATE(), 113) --结果： 02 01 2019 21:33:18:780 SELECT CONVERT(varchar(100), GETDATE(), 114) --结果： 21:33:18:780 SELECT CONVERT(varchar(100), GETDATE(), 120) --结果： 2019-01-02 21:33:18 SELECT CONVERT(varchar(100), GETDATE(), 121) --结果： 2019-01-02 21:33:18.780 10、SQL中的相除方法一 --SQL中的相除 SELECT CASE WHEN ISNULL(A-B,0)=0 THEN &#39;&#39; ELSE CAST(CONVERT(DECIMAL(18,2),A*100.0/(A-B)) AS VARCHAR(10))+&#39;%&#39; END AS &#39;百分数&#39; --FROM 表 这里我们先要判断被除数是否为0，如果为0给出一个想输出的结果，这里我们返回空白(是字符类型，不是NULL)，在不为0的时候就给出具体的计算公式，然后转换成字符类型再和“%”进行拼接。例如： SELECT CASE WHEN ISNULL(5-2,0)=0 THEN &#39;&#39; ELSE CAST(CONVERT(DECIMAL(18,2),5*100.0/(5-2)) AS VARCHAR(10))+&#39;%&#39; END AS &#39;百分数&#39; --FROM 表 返回的结果： 方法二 SELECT (CONVERT(VARCHAR(20),ROUND(41*100.0/88,3))+&#39;%&#39;) AS &#39;百分比&#39; --FROM A 执行结果： 11、四舍五入ROUND函数ROUND ( numeric_expression , length [ ,function ] )function 必须为 tinyint、smallint 或 int。如果省略 function 或其值为 0（默认值），则将舍入 numeric_expression。如果指定了0以外的值，则将截断 numeric_expression。 SELECT ROUND(150.45648, 2); --保留小数点后两位，需要四舍五入 --结果： 150.46000 SELECT ROUND(150.45648, 2, 0); --保留小数点后两位，0为默认值，表示进行四舍五入 --结果： 150.46000 SELECT ROUND(150.45648, 2, 1); --保留小数点后两位，不需要四舍五入，这里除0以外都是有同样的效果， --与Oracle的TRUNC函数效果相同 --结果： 150.45000 SELECT ROUND(150.45648, 2, 2); --保留小数点后两位，不需要四舍五入，这里除0以外都是有同样的效果， --与Oracle的TRUNC函数效果相同 --结果： 150.45000 12、对字段出现NULL值的处理方法一 --CASE SELECT CASE WHEN &#39;字段名&#39; IS NULL THEN &#39;NULL&#39; ELSE CONVERT(VARCHAR(20),&#39;字段名1&#39;) END AS &#39;NewName&#39; --结果： 字段名1 SELECT CASE WHEN NULL IS NULL THEN &#39;N&#39; ELSE CONVERT(VARCHAR(20),NULL) END AS &#39;NewName&#39; --结果： N 方法二 --SQL Server 2005：COALESCE SELECT COALESCE(&#39;字符串类型字段&#39;,&#39;N&#39;) AS &#39;NewName&#39; --结果： 字符串类型字段 SELECT COALESCE(CONVERT(VARCHAR(20),&#39;非字符串类型字段&#39;),&#39;N&#39;) AS &#39;NewName&#39; --结果： 非字符串类型字段 SELECT COALESCE(CONVERT(VARCHAR(20),NULL),&#39;N&#39;) AS &#39;NewName&#39; --结果： N --COALESCE,返回其参数中的第一个非空表达式 SELECT COALESCE(NULL,NULL,1,2,NULL) --结果： 1 SELECT COALESCE(NULL,11,12,13,NULL) --结果： 11 SELECT COALESCE(111,112,113,114,NULL) --结果： 111 13、COUNT的几种情况--以下三种方法均可统计出表的记录数 --第一种 select count(*) from tablename --第二种 select count(ID) from tablename --第三种,1换成其它值也是可以的 select count(1) from tablename 14、UNION ALL多表插入把两个相同结构的表union后插入到一个新表中，当然两个以上的相同结构的表也是可以的，这里的相同是指两个或多个表的列数和每个对应列的类型相同，列名称可以不同 select * into table_new from table_1 union all select * from table_2 15、查看数据库缓存的SQLuse master declare @dbid int Select @dbid = dbid from sysdatabases where name = &#39;SQL_ROAD&#39;--修改成数据库的名称 select dbid,UseCounts ,RefCounts,CacheObjtype,ObjType, DB_Name(dbid) as DatabaseName,SQL from syscacheobjects where dbid=@dbid order by dbid,useCounts desc,objtype 我们可以看到数据库中当前正在运行的SQL有哪些 16、删除计划缓存--删除整个数据库的计划缓存 DBCC FREEPROCCACHE --删除某个数据库的计划缓存 USE master DECLARE @dbid INT SELECT @dbid=dbid FROM sysdatabases WHERE NAME = &#39;SQL_ROAD&#39; DBCC FLUSHPROCINDB (@dbid) 17、SQL换行SQL的换行制表符 CHAR(9)换行符 CHAR(10)回车 CHAR(13) PRINT &#39;SQL&#39;+CHAR(13)+&#39;ROAD&#39; PRINT &#39;SQL&#39;+CHAR(10)+&#39;ROAD&#39; PRINT &#39;SQL&#39;+CHAR(9)+&#39;ROAD&#39; 执行结果： 如果将查询结果以文本格式显示，而不是网格格式显示，SELECT语句也适用，我们先将查询结果改成以文本格式显示 --以文本格式显示结果 SELECT &#39;SQL&#39;+ CHAR(10)+&#39;ROAD&#39; SELECT &#39;SQL&#39;+ CHAR(13)+&#39;ROAD&#39; SELECT &#39;SQL&#39; + CHAR(10) + CHAR(13) + &#39;ROAD&#39; 结果如下： 18、TRUNCATE TABLE [Table Name]TRUNCATE 是SQL中的一个删除数据表内容的语句，用法是： TRUNCATE TABLE [Table Name] 速度快,而且效率高,因为:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。 如果想保留标识计数值，请改用 DELETE。 如果要删除表定义及其数据，请使用 DROP TABLE 语句。对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。TRUNCATE TABLE 不能用于参与了索引视图的表。 19、常用系统检测脚本--查看内存状态 dbcc memorystatus --查看哪个引起的阻塞，blk EXEC sp_who active --查看锁住了那个资源id，objid EXEC sp_lock 还有如何查看查询分析器的SPID，可以在查询分析器的状态栏看到，比如sa(57),这就表示当前查询分析器SPID为57,这样在使用profile的时候就可以指定当前窗体进行监控。状态栏在查询窗口的右下角。 20、获取脚本的执行时间declare @timediff datetime select @timediff=getdate() select * from Suppliers print &#39;耗时:&#39;+ convert(varchar(10),datediff(ms,@timediff,getdate())) 结果如下： 在状态栏是不会精确到毫秒的，只能精确到秒 这个脚本可以更加有效的查看SQL代码的执行效率。","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"经典SQL语句大全","slug":"经典SQL语句大全","date":"2019-09-30T16:00:00.000Z","updated":"2020-07-08T16:27:16.814Z","comments":true,"path":"2019/10/01/经典SQL语句大全/","link":"","permalink":"http://smilecoc.vip/2019/10/01/经典SQL语句大全/","excerpt":"","text":"一、基础部分 1、创建数据库 CREATE DATABASE dbname 2、删除数据库 DROP DATABASE dbname 3、创建新表 CREATE TABLE tabname( col1 type1 [not null] [primary key], col2 type2 [not null],.. ) 根据已有的表创建新表/使用旧表创建新表: create table tab_new as select col1, col2… from tab_old 4、删除新表 DROP TABLE tablename 5、增加一个列 Alter table tabname add column col type 6、添加主键： Alter table tabname add primary key(col) 删除主键： Alter table tabname drop primary key(col) 7、创建索引： create [unique] index idxname on tabname(col….) 删除索引： drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 8、创建视图： create view viewname as select statement 删除视图： drop view viewname 9、几个简单的sql语句–选择： select * from table1 where 范围 –插入： insert into table1(field1,field2) values(value1,value2) –删除： delete from table1 where 范围 –更新： update table1 set field1=value1 where 范围 –查找： select * from table1 where field1 like ’%value1%’ –排序： select * from table1 order by field1,field2 [desc] –总数： select count as totalcount from table1 –求和： select sum(field1) as sumvalue from table1 –平均： select avg(field1) as avgvalue from table1 –最大： select max(field1) as maxvalue from table1 –最小： select min(field1) as minvalue from table1 10、几个高级查询运算词 A：UNION 运算符UNION 运算符通过组合其他两个结果表，并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 B：EXCEPT 运算符EXCEPT运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 C：INTERSECT 运算符 INTERSECT运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。 11、使用外连接A、left （outer） join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c B：right （outer） join 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 C：full/cross （outer） join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 12、Group by 对列进行分组，常与聚合函数(count,sum,max,min,avg )一起使用 注意： 在分组时：不能以text,ntext,image类型的字段作为分组依据 在select统计函数中的字段，不能和普通的字段放在一起； 二、进阶部分 1、复制表(只复制表结构,源表名：a 新表名：b)–方法一 仅用于SQL Server： select * into b from a where 1&lt;&gt;1 –方法二： select top 0 * into b from a 2、拷贝表(拷贝数据,源表名：a 目标表名：b) insert into b(a, b, c) select d,e,f from b; 3、子查询(表名1：a 表名2：b) select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3) 4、显示文章、提交人和最后回复时间 select a.title, a.username, b.adddate from table a, (select max(adddate) adddate from table where table.title=a.title) b 5、外连接查询(表名1：a 表名2：b) select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c 6、在线视图查询(表名1：a ) select * from ( SELECT a,b,c FROM a ) T where t.a &gt; 1; 7、between的用法,between限制查询数据范围时包括了边界值,not between不包括 select * from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2 8、in 的使用方法 select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’) 9、两张关联表，删除主表中已经在副表中没有的信息 delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 ) 10、四表联查问题： select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where ... 11、日程安排提前五分钟提醒 select * from 日程安排 where datediff(&#39;minute&#39;,f开始时间,getdate())&gt;5 12、一条sql 语句搞定数据库分页 select top 10 b.* from ( select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc ) a, 表名 b where b.主键字段 = a.主键字段 order by a.排序字段具体 实现：关于数据库分页： declare @start int,@end int @sql nvarchar(600) set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in( select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’ exec sp_executesql @sql 13、前10条记录 select top 10 * form table1 where 范围 14、包括所有在 TableA中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表 (select a from tableA ) except (select a from tableB) except (select a from tableC) 15、随机取出10条数据 select top 10 * from tablename order by newid() 16、说明：删除重复记录 --方法一 delete from tablename where id not in (select max(id) from tablename group by col1,col2,...) --方法二 select distinct * into temp from tablename delete from tablename insert into tablename select * from temp 评价：这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段 alter table tablename --添加一个自增列 add column_b int identity(1,1) delete from tablename where column_b not in( select max(column_b) from tablename group by column1,column2,... ) alter table tablename drop column column_b 17、列出数据库里所有的表名 use master go select name from sysobjects where type=&#39;U&#39; // U代表用户 18、列出表里的所有的列名 use master go select name from syscolumns where id=object_id(&#39;TableName&#39;) 19、初始化表table1 TRUNCATE TABLE table1 20、选择从10到15的记录 select top 5 * from ( select top 15 * from table order by id asc ) table_别名 order by id desc 三、开发技巧 1、where 1=1是表示选择全部，where 1=2全部不选 if @strWhere !=&#39;&#39; begin set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where &#39; + @strWhere end else begin set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;]&#39; end 我们可以直接写成 set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where 1=1 &#39;+ @strWhere 2、收缩数据库 --重建索引 DBCC REINDEX DBCC INDEXDEFRAG --收缩数据和日志 DBCC SHRINKDB DBCC SHRINKFILE 3、压缩数据库 dbcc shrinkdatabase(dbname) 4、转移数据库给新用户以已存在用户权限 exec sp_change_users_login &#39;update_one&#39;,&#39;newname&#39;,&#39;oldname&#39; go 5、检查备份集 RESTORE VERIFYONLY from disk=&#39;E:\\dvbbs.bak&#39; 6、修复数据库 ALTER DATABASE [dvbbs] SET SINGLE_USER GO DBCC CHECKDB(&#39;dvbbs&#39;,repair_allow_data_loss) WITH TABLOCK GO ALTER DATABASE [dvbbs] SET MULTI_USER GO 7、日志清除 SET NOCOUNT ON DECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INT USE tablename -- 要操作的数据库名 SELECT @LogicalFileName = &#39;tablename_log&#39;, -- 日志文件名 @MaxMinutes = 10, -- Limit on time allowed to wrap log. @NewSize = 1 -- 你想设定的日志文件的大小(M) Setup / initialize DECLARE @OriginalSize int SELECT @OriginalSize = size FROM sysfiles WHERE name = @LogicalFileName SELECT &#39;Original Size of &#39; + db_name() + &#39; LOG is &#39; + CONVERT(VARCHAR(30),@OriginalSize) + &#39; 8K pages or &#39; + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + &#39;MB&#39; FROM sysfiles WHERE name = @LogicalFileName CREATE TABLE DummyTrans (DummyColumn char (8000) not null) DECLARE @Counter INT, @StartTime DATETIME, @TruncLog VARCHAR(255) SELECT @StartTime = GETDATE(), @TruncLog = &#39;BACKUP LOG &#39; + db_name() + &#39; WITH TRUNCATE_ONLY&#39; DBCC SHRINKFILE (@LogicalFileName, @NewSize) EXEC (@TruncLog) -- Wrap the log if necessary. WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) AND (@OriginalSize * 8 /1024) &gt; @NewSize BEGIN -- Outer loop. SELECT @Counter = 0 WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000)) BEGIN -- update INSERT DummyTrans VALUES (&#39;Fill Log&#39;) DELETE DummyTrans SELECT @Counter = @Counter + 1 END EXEC (@TruncLog) END SELECT &#39;Final Size of &#39; + db_name() + &#39; LOG is &#39; + CONVERT(VARCHAR(30),size) + &#39; 8K pages or &#39; + CONVERT(VARCHAR(30),(size*8/1024)) + &#39;MB&#39; FROM sysfiles WHERE name = @LogicalFileName DROP TABLE DummyTrans SET NOCOUNT OFF 8、更改某个表 exec sp_changeobjectowner &#39;tablename&#39;,&#39;dbo&#39; 9、存储更改全部表 CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch @OldOwner as NVARCHAR(128), @NewOwner as NVARCHAR(128) AS DECLARE @Name as NVARCHAR(128) DECLARE @Owner as NVARCHAR(128) DECLARE @OwnerName as NVARCHAR(128) DECLARE curObject CURSOR FOR select &#39;Name&#39; = name, &#39;Owner&#39; = user_name(uid) from sysobjects where user_name(uid)=@OldOwner order by name OPEN curObject FETCH NEXT FROM curObject INTO @Name, @Owner WHILE(@@FETCH_STATUS=0) BEGIN if @Owner=@OldOwner begin set @OwnerName = @OldOwner + &#39;.&#39; + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwner end -- select @name,@NewOwner,@OldOwner FETCH NEXT FROM curObject INTO @Name, @Owner END close curObject deallocate curObject GO 10、SQL SERVER中直接循环写入数据 declare @i int set @i=1 while @i&lt;30 begin insert into test (userid) values(@i) set @i=@i+1 end 案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格: Name score Zhangshan 80 Lishi 59 Wangwu 50 Songquan 69 while((select min(score) from tb_table)&lt;60) begin update tb_table set score =score*1.01 where score&lt;60 if (select min(score) from tb_table)&gt;60 break else continue end","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"SQL&数据库","slug":"SQL-数据库","permalink":"http://smilecoc.vip/tags/SQL-数据库/"}],"author":"smilecoc"},{"title":"博客搭建记录","slug":"我的博客搭建全记录","date":"2019-08-20T04:34:02.000Z","updated":"2020-07-07T14:49:06.482Z","comments":true,"path":"2019/08/20/我的博客搭建全记录/","link":"","permalink":"http://smilecoc.vip/2019/08/20/我的博客搭建全记录/","excerpt":"","text":"本博客利用hexo+github搭建，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用，并希望可以为其他有需要的人提供前车之鉴，少走弯路。 开始搭建安装node.js下载node.js并安装（官网下载安装），默认会安装npm。打开cmd命令行，成功的标志如下： 安装git下载安装git（官网下载安装）,安装成功的象征就是在电脑上任何位置鼠标右键能够出现Git GUI Here和Git Bash here如下两个选择注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大 Github建立项目Github账户注册和新建项目（new repository），项目必须要遵守格式：账户名.github.io，并且需要勾选Initialize this repository with a README。在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 安装hexo安装Hexo，在自己认为合适的地方建了一个blog文件夹。然后通过命令行进入到该文件夹里面为什么要新创建blog文件呢？因为hexo 初始化需要文件夹为null的，所以确保路径简单且路径中不要有中文输入npm install hexo -g，开始安装Hexo输入** hexo -v 查看是否安装成功，如果成功安装会显示出安装的版本信息输入hexo init，初始化该文件夹（有点漫长的等待。。。）个人在这一步一直出现报错，先出现‘git’ is not recognized as an internal or external command错误，后来又出现Permission denied错误，耽误了好几个小时，后来发现使用hexo init 都可以解决看到 Start blogging with Hexo！ 则表明安装成功。在cmd中输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址（即提示中的http://localhost:4000/），正式体验Hexo如果页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号**来改变端口号 连接Hexo与Github将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）首先在新建的blog文件夹里面鼠标右键，点击Git Bash Here。这里“06866”可以替换成自己的用户名，邮箱可以替换成自己的邮箱输入cd ~/.ssh，检查是否由.ssh的文件夹 ls 查看ssh 密钥生成连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub接着输入eval “$(ssh-agent -s)”，回车，添加密钥到ssh-agent再输入ssh-add ~/.ssh/id_rsa，回车，添加生成的SSH key到ssh-agent接着登录Github，点击头像下的settings，点击new ssh key输入cat id_rsa.pub生成一个new ssh key，将生成后的内容复制到上一步的github中的new ssh key中输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 如果ssh-key配置失败，那么只要按照以下步骤就能完全解决 首先，清除所有的key-pair，输入ssh-add -D和rm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对，输入ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key: 1、首先在你的终端运行xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板 2、在github上添加公钥时，直接复制即可 3、保存 测试：在终端ssh -T git@github.com 修改Deployment值在之前新建的blog文件夹中，找到_config.yml文件，修改Deployment值（在末尾）,将 deploy: type: 更改为： deploy: type: git repository: git@github.com:xxxx/xxxx.github.io.git branch: master repository值是你在github项目里的ssh（右下角） 完成建站并新建博客新建一篇博客，在cmd执行命令：hexo new post “博客名”，就可以在blog/_posts/中找到已创建的文件。在生成以及部署文章之前，需要安装一个扩展，在cmd中输入npm install hexo-deployer-git –save，并将刚刚生成的文件编辑好后cmd中输入命令hexo d -g即可生成部署文章 至此，一个具备基础功能的博客就完成了 绑定自己的域名购买域名国内的域名服务商有新网，腾讯云，还有阿里云的万网等。下面以阿里云的万网为例：在万网购买了自己心仪的域名后，进入阿里云的管理控制台-域名与网站-域名就可以看到购买的域名此时的域名状态是未实名认证的，然后就是实名认证（一般需要2小时左右）。 域名解析首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：ping username.github.io,其中username为自己的github用户名 下面通过 DNS域名解析将购买的域名指向 github 的二级域名：username.github.io，进入阿里云的管理控制台-域名与网站-云解析 DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现： 记录值就是自己 github 的二级域名的 IP地址。 设置CNAME在 本地hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如： 在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：这样新域名配置完成，可以使用新的网名访问自己的博客了 更换主题Hexo有许多的个性化主题可供选择，有兴趣的可以直接搜索hexo主题进入hexo的官网查看，我使用的是hexo sakura主题，github 地址为https://github.com/honjun/hexo-theme-sakura，在这里也能找到主题的大部分使用方法，这一部分主要是作者的教程+一些自己摸索出来的教程+其他搜索问题时的教程 主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 主题配置找到 /themes/sakura/config.yml 这个配置文件中修改，跟着作者的注释修改即可。注意一下所有的文件带有注释，所以最好找到自己的电脑中的文件对照改，以免出错。 站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名，即网站的左上角的名称 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改为自己的博客的网址】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ CDN搭建这其中涉及到搭建cdn,可以直接去视屏地址看，直接看文字版如下： 国内加载github的资源比较慢，需要使用CDN加速来优化网站打开速度，于是使用jsDeliver+github搭建免费的cdn。jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源 什么是CDNCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 国内加载github的资源比较慢，需要使用CDN加速来优化网站打开速度，于是使用jsDeliver+github搭建免费的CDN，非常适合博客网站使用。 jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。 NPM是JavaScript的包管理器，也是世界上最大的软件注册中心。发现可重用代码的包——并以强大的新方式组装它们。每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 所以jsDeliver+npm就是把npm上的包当做cdn的存储。jsDeliver不支持加载超过20M的资源，所以一些视频最好压缩到20M以下 第一步：新建github仓库 第二步：克隆Github仓库到本地 $ git clone 你的仓库链接 # 本地克隆github仓库 第三步：上传需要的资源在本地目录右键 Git Bash Here,复制需要的静态资源到本地git仓库中，提交到github仓库上。亦可以github直接上传文件命令如下： // 查看状态 git status // 添加到库中 git add . // 提交更新（引号内 为自定义信息说明） git commit -m &#39;第一次提交&#39; // 推送至远程仓库 git push第四步：发布仓库点击release发布 发布版本号为1.0（自定义） 同时也可以直接在建立的仓库中直接上传文件，这一部分是github的操作，不多赘述 第五步：通过jsDeliver引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径比如：//加载图片https://cdn.jsdelivr.net/gh/Zevs6/CDN/img/avatar.jpg 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： // 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js // 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 子页面与其他细节修改：去掉prefixName如果想去掉prefixName（网页左上角的网站名称前半部分），可在 /themes/sakura/source/css/style.css下修改了样式表去掉prefixName即可。大家如果想修改其相关的样式也可以去这个css文件中自定义,这个文件是主要的css文件，大部分的样式都是由这个文件定义的。 网页顶部导航栏网页顶部导航栏可以在/themes/sakura/config.yml中的meuns:下修改，如果有需要，可以修改名称，也可以直接删除，生成的网页会随之变动前面的path是网页路径，这个不建议修改，但可以修改。后面的如: fa: fas fa-home fa-1x 这个就是对应的图标设置,关于这个图标大家可以去fontawesome看教程以及选择自己喜欢的图标，导航栏下拉下拉菜单的图标修改和导航栏相同。 社交栏样式社交栏的样式在 /themes/sakura/source/css/style.css中可以修改， Ctrl+f 搜索 header-info即可，建议没有必要就不修改了 模块更名startdash模块更改名称：在 /themes/sakura/layout/_partial/startdash.ejs中有： &lt;div class=&quot;top-feature-row&quot;&gt; &lt;h1 class=&quot;fes-title&quot; style=&quot;font-family: &#39;Ubuntu&#39;, sans-serif;&quot;&gt; &lt;i class=&quot;fa fa-anchor&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; startdash&lt;/h1&gt; &lt;% for (dash in theme.startdash) { %&gt; .... 更改其中的startdash即可同样如果要更改discovery模块的名称，在/themes/sakura/layout/index.ejs中找到如下代码： &lt;h1 class=&quot;main-title&quot; style=&quot;font-family: &#39;Ubuntu&#39;, sans-serif;&quot;&gt; &lt;i class=&quot;fa fa-envira&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Discovery&lt;/h1&gt; &lt;%- partial(&#39;_partial/archive&#39;, {pagination: 2, index: true}) %&gt; &lt;!-- 首页默认取最最新文章集 --&gt; 修改discovery即可 文章的封面，归档设置在你写博客时的md文件中可以自由设置，下面是示例： title: Sakura美化教程#文章的标题 author: hojun#作者名称 avatar: https://wx1.sinaimg.cn/large/006bYVyvgy1ftand2qurdj303c03cdfv.jpg#文章标题下作者的图标，如果不加会导致图片缺失，比较丑 authorLink: https://yremp.club#作者链接 authorAbout: authorDesc: categories: 技术#对应网页顶部导航栏归档 date: 2019-5-26 12:16:01 comments: true tags: - web keywords: Sakura主题自定义美化教程 description: Sakura美化教程 photos: https://static.2heng.xin/wp-content/uploads//2019/02/wallhaven-672007-1-1024x576.png#封面的图片链接 --- 归档子页面归档子页面下的图片/封面设置在 /themes/sakura/language/zh-cn.yml，找到如下代码： #category 技术: zh: 野生技术协会 en: Technical Communication img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(1).jpg.webp 生活: zh: 生活 en: Live img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(2).jpg.webp ...... 这一个子页面同样是和之前设置的相关的，自己有几个归档分类就自己添加即可 悦读和图集在 /themes/sakura/language/zh-cn.yml修改： #tag 悦读: img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(6).jpg.webp 图集: img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(5).jpg.webp web: img: https://cdn.jsdelivr.net/gh/yremp/resource@1.0/img/pic.jpg 番组注意：这个souce文件夹需要放在blog一级的文件夹下，如果没有的话在下载的sakura文件中复制粘贴这个页面对应的配置是在 /source/bangumi/index.md中修改，其中代码如下,对照网页修改即可 --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: - img: http://pic.netbian.com/uploads/allimg/180413/121552-152359295246db.jpg title: 狐妖小红娘 status: 追番中 progress: 100 jp: 狐妖小红娘 time: 2019-05-24 SUN. desc: 白月初…… - img: http://pic.netbian.com/uploads/allimg/170605/130458-149663909840b3.jpg title: 名侦探柯南 status: 追番中 progress: 1000 jp: 名探偵コナン time: 2019-05-24 SUN. desc: 中生侦探工藤新一…… --- 歌单整个页面配置在 /source/music/index.md中： --- title: music date: 2018-12-20 23:14:28 keywords: 喜欢的音乐 description: comments: false photos: http://pic.netbian.com/uploads/allimg/170911/233802-15051442827782.jpg --- &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=762797776&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; photos就是这个页面的顶部图片，id就是网易云音乐歌单id，登录网页版网易云音乐，打开歌单就可以在网址中找到 友链配置友情链接内容配置具体在 /source/link/index.md中，界面背景及布局主要在/themes/sakura/layout/links.ejs 其他事项 网页顶部导航栏归档如果某一个分类下没有添加文件，则会出现not foung页面，所以对应的上一步中的categories需要与_config文件中的对应 注意所有的md文件中的：后都有一个空格（不知道改如何叫，键值对？） 其他的后续问题，bug等归纳整理到Hexo Sakura主题遇到的问题汇总供参考 添加一个看板娘就是右下角的卡通人物 基础版看板娘项目地址 live2d模型 部分模型预览 首先进入Hexo博客根目录安装live2d插件 $ npm install --save hexo-helper-live2d 接着，修改根目录下的 *_config.yml *文件 添加自定义配置(下面提供我的配置做参考)： ## live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-z16 scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: true scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 细心一点肯定能发现 model.use 后的字符串就是看板娘模型的名字 现在你就可以进入模型预览 挑选自己喜欢的看板娘啦 现在假设你所挑选的看板娘也是z16 你有几种方式让看板娘进驻你的Hexo博客，这里只提供最方便的一种(命令安装)。 进入博客根目录输入以下命令： $ npm install live2d-widget-model-z16 再将 *_config.yml *中 model.use检查 一遍确保与你安装的名称一致 到此处看板娘进驻成功 进阶版看板娘如何安装看板娘傻瓜式安装只需在网页中引入这三行代码即可 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 在 主题配置文件 中,新增如下内容： live2d: enable: true 如果你想折腾一翻，请看下面本插件需要jQuery和font-awesome支持，请确保它们已在页面中加载，例如在中加入： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt; 否则无法正常显示。（如果你的网页已经加载了jQuery，就不要重复加载了） 你可以直接这样使用： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 将这一行代码加入或，即可看到效果。如果你的网站启用了PJAX，由于看板娘不必每页刷新，因此需要注意将相关脚本放到PJAX刷新区域之外。 换句话说，如果你是小白，或者只需要最基础的功能，就只需要： 把这一行代码，连同前面的两行代码，一起放到html的中即可；如果页面是用各种模版引擎、php、asp生成的，也要自行修改，方法类似，只是可能略为麻烦。但是！我们强烈推荐自己进行配置，否则很多功能是不完整的，并且可能产生问题！如果你还有兴趣自己折腾的话，请看下面的详细说明。算了不搞你们了，如果搞不到，请使用傻瓜式安装 如果要自定义有关内容，可以把这个仓库Fork一份，然后进行修改。这时，使用方法对应地变为 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/username/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 将username替换为你的GitHub用户名即可。 定制看板娘的语录1.从github中下载项目: https://github.com/stevenjoezhang/live2d-widget2.更改waifu-tip.json里面的内容详情3.更改autoload.js的引入位置将下载的文件解压到本地博客目录的themes/主题文件夹/source下，修改autoload.js文件，如下： 将 改成const live2d_path = “/live2d-widget/“; 想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。 推荐一个 Live2D 模型资源收集站：https://mx-model.ga/","categories":[{"name":"技术","slug":"技术","permalink":"http://smilecoc.vip/categories/技术/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://smilecoc.vip/tags/blog/"}],"author":"smilecoc"},{"title":"2019年，小破站建立撒花~","slug":"2019年随想","date":"2019-08-05T16:00:00.000Z","updated":"2020-02-23T09:54:21.174Z","comments":true,"path":"2019/08/06/2019年随想/","link":"","permalink":"http://smilecoc.vip/2019/08/06/2019年随想/","excerpt":"","text":"2019年8月6日，小破站成功建立起来啦~恭喜又新增了一个坑（囧） 今年开了很多的新坑，以后要一个一个填上~ 关于我的其他新开的坑，请关注–&gt; 微信公众号：Romi的杂货铺，时不时的会写一些文章 B站：up主的主页，时不时的会转载和制作一些视频 简书：简书主页，一些转载的，原创的，各种杂乱的文章可能都有","categories":[{"name":"随想","slug":"随想","permalink":"http://smilecoc.vip/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://smilecoc.vip/tags/随想/"}],"author":"smilecoc"},{"title":"RFM用户模型","slug":"RFM用户分析模型","date":"2019-03-12T14:22:30.000Z","updated":"2020-03-12T15:45:31.355Z","comments":true,"path":"2019/03/12/RFM用户分析模型/","link":"","permalink":"http://smilecoc.vip/2019/03/12/RFM用户分析模型/","excerpt":"","text":"","categories":[{"name":"转载","slug":"转载","permalink":"http://smilecoc.vip/categories/转载/"}],"tags":[{"name":"Python数据分析","slug":"Python数据分析","permalink":"http://smilecoc.vip/tags/Python数据分析/"}],"author":"smilecoc"}]}